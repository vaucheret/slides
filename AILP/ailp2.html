<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Interpretación Abstracta de Programas Logicos</title>
<meta name="author" content="(Claudio Vaucheret)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js-master/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js-master/css/theme/league.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js-master/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition=""><h1 class="title">Interpretación Abstracta de Programas Logicos</h1><h2 class="author">Claudio Vaucheret</h2><h2 class="date">Segunda Parte</h2><p class="date">Created: 2020-09-12 sáb 04:04</p>
</section>
<section id="table-of-contents">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org802d08e">Análisis de programas lógicos</a></li>
<li><a href="#/slide-org1d38abf">Caso de Estudio: Semántica de punto fijo</a></li>
<li><a href="#/slide-org3a50643">Semántica de punto fijo: Ejemplo</a></li>
<li><a href="#/slide-orge050864">Interpretación abstracta "Bottom up"</a></li>
<li><a href="#/slide-org858c835">Interpretación abstracta "Bottom up" (cont.)</a></li>
<li><a href="#/slide-orge8fa6d5">Ejemplo: simple inferencia de "tipos"</a></li>
<li><a href="#/slide-org68e822a">Ejemplo: simple inferencia de "tipos" (cont.)</a></li>
<li><a href="#/slide-org0e2fcda">Ejemplo: simple inferencia de "tipos" (cont.)</a></li>
<li><a href="#/slide-org2d6cb22">Análisis <b>bottom up</b> basado en \(T_P\): Discusión</a></li>
<li><a href="#/slide-org9360cab">Análisis <b>Top down</b> (resumido)</a></li>
<li><a href="#/slide-orgafa5a08">Arbol AND-OR abstracto</a></li>
<li><a href="#/slide-orgbc9f53c">Optimización de Punto Fijo</a></li>
</ul>
</div>
</nav>
</section>


<section id="slide-org802d08e" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org802d08e">Análisis de programas lógicos</h2>
<ul>
<li class="fragment roll-in">¿Qué semántica?
<ul>
<li>Semántica declarativa: relacionada a qué es una consecuencia del programa
<ul>
<li>Semántica de la teoría de modelos mínimos</li>
<li>Semántica de punto fijo (basada en el operador \(T_P\))
(cf. estilo de base de datos, evaluación bottom-up )</li>

</ul></li>
<li>Semántica operativa: cercana al comportamiento del programa
<ul>
<li>Basado en resolución SLD (conjuntos éxitosos)</li>
<li>Denotacional</li>
<li>Puede cubrir posibilidades distintas a SLD: reactivo, paralelo, &#x2026;</li>

</ul></li>

</ul></li>
<li class="fragment roll-in">Los análisis basados en semántica declarativa a menudo se denominan análisis <b>bottom up</b></li>
<li class="fragment roll-in">Los análisis basados en la semántica operativa (de arriba hacia
abajo) a menudo se denominan Análisis <b>top down</b></li>
<li class="fragment roll-in">Además, casos intermedios (generalmente logrados mediante la
transformación de programas)</li>

</ul>


<div class="slide-footer"></div>
</section>
<section id="slide-org1d38abf" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org1d38abf">Caso de Estudio: Semántica de punto fijo</h2>
<ul>
<li class="fragment roll-in">Dado el lenguaje de primer orden \(L\) asociado con un programa \(P\)
dado, el universo de Herbrand (\(U\)) es el conjunto de todos los
términos básicos de \(L\).</li>
<li class="fragment roll-in">La Base de Herbrand (\(B\)) es el conjunto de todos los átomos
instanciados (<i>ground</i>) de \(L\).</li>
<li class="fragment roll-in">Una <i>interpretación de Herbrand</i> es un subconjunto de \(B\). \(I\) es el
conjunto de todas las interpretaciones de Herbrand (\(\wp(B)\))</li>
<li class="fragment roll-in">Un <i>modelo de Herbrand</i> es una interpretación de Herbrand que contiene
todos las consecuencias del programa.</li>
<li class="fragment roll-in">El operador de consecuencia inmediata (\(T_P\)) es un mapeo \(T_P : I
  \rightarrow I\) definido por: \[T_P(M) = \{h \in B \vert \exists C
  \in ground(P), C = h \leftarrow b_1, \ldots, b_n \mbox{ y } b_1, \ldots,
  b_n \in M\}\] (en particular, si (\(a \leftarrow\)) &isin; \(P\), entonces \(ground(a) \subseteq T_P(M)\), para cada \(M\)).</li>
<li class="fragment roll-in">\(T_P\) es monótono, por lo que tiene un minimo punto fijo \(lfp(T_P)\)
que se puede obtener como \(T_P \uparrow \omega\) comenzando desde el
elemento inferior del retículo (la interpretación vacía, \(\emptyset\)).</li>
<li class="fragment roll-in">(Teorema de caracterización) [Van Emden y Kowalski]: El menor modelo de Herbrand \(P\), \(H\) es \(lfp(T_P)\)</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org3a50643" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org3a50643">Semántica de punto fijo: Ejemplo</h2>
<p>
\(P = \{ p(f(X)) \leftarrow p(X). \\
        p(a). \\
        q(a). \\
        q(b). \}\)
</p>

<div>
\begin{align}
U &= \{ a,b,f(a),f(b),f(f(a)),f(f(b)),\ldots \} \\

B &= \{ p(a),p(b),q(a),q(b),p(f(a)),p(f(b)),p(f(f(a))),p(f(f(b))),q(f(a))\ldots  \} \\

I &= \mbox{ todos los subconjuntos de } B \\

H &= \{ q(a), q(b), p(a), p(f(a)), p(f(f(a))), \ldots \} \\
\end{align}      

</div>

<div>
\begin{align}
T_P \uparrow 0 &= \{ p(a),q(a),q(b) \}\\

T_P \uparrow 1 &= \{ p(a),q(a),q(b),p(f(a)) \} \\

T_P \uparrow 2 &= \{ p(a),q(a),q(b),p(f(a)),p(f(f(a))) \} \\

\ldots \\

T_P \uparrow \omega &= H \\
\end{align}      

</div>


<div class="slide-footer"></div>
</section>
<section id="slide-orge050864" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="orge050864">Interpretación abstracta "Bottom up"</h2>
<ul>
<li>Encuentra una aproximación de \(H\) al aproximar \(lfp(T_P)\)</li>
<li>Aplicamos interpretación abstracta:
<ul>
<li>Dominio: \(I^\alpha\), tal que elementos de \(I^\alpha\) aproxima elementos de \(I = \wp(B)\).</li>
<li>Función de concretización: \(\gamma: I^\alpha \rightarrow I\)</li>
<li>Función de abstracción: \(\alpha: I \rightarrow I^\alpha\)</li>
<li>Operador Abstracto: versión abstracta del operador \(T_P\)  \(T^\alpha_P : I^\alpha \rightarrow I^\alpha\)</li>
<li>Exactitud:
<ul>
<li>\((I^\alpha, \gamma, I, \alpha)\) debe ser una inserción de
Galois, es decir, \(I^\alpha\) retículo completo y debería
aproximar a \(I: \forall M \in I, \gamma(\alpha(M)) \supseteq M\)</li>
<li>\(T^\alpha_P\) aproximación segura de \(T_P\), es decir, \(\forall d,
      d \in  I^\alpha, \gamma(T^\alpha_P(d)) \supseteq T_P(\gamma(d))\)</li>

</ul></li>
<li>Terminación:
<ul>
<li>\(T^\alpha_P\) es monótono.</li>
<li>\(I^\alpha\) (al menos) cadena ascendente finita.</li>

</ul></li>

</ul></li>
<li>Entonces, \(H^\alpha = lfp(T^\alpha_P) = T^\alpha_P \uparrow n\) se
obtendrá en un número finito de pasos \(n\) y \(H^\alpha\) se aproximará a \(H\).</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org858c835" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org858c835">Interpretación abstracta "Bottom up" (cont.)</h2>

<figure>
<img src="bottomup2.png" alt="bottomup2.png">

</figure>


<div class="slide-footer"></div>
</section>
<section id="slide-orge8fa6d5" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="orge8fa6d5">Ejemplo: simple inferencia de "tipos"</h2>
<ul>
<li>Problema de "inferencia de tipo" mínimal [Sondergaard]: Aproximación
de qué predicados están en \(H\)</li>
<li>\(pred(a):\) denota el símbolo de predicado de un átomo \(a\)</li>
<li>\(B^\alpha = S\) (conjunto de símbolos de predicado en un programa
\(P\)) Entonces \(I^\alpha = \wp(S)\), lo llamamos \(S^*\)</li>
<li>Función de concretización:
<ul>
<li>\(\gamma: S^* \rightarrow I\)</li>
<li>\(\gamma(D) = \{a \in B | pred(a) \in D \}\)</li>

</ul></li>
<li>Función de abstracción:
<ul>
<li>\(\alpha: I \rightarrow S^*\)</li>
<li>\(\alpha(M) = \{p \in S | \exists a \in M, pred(a) = p \}\)</li>

</ul></li>
<li>\((S^*, \gamma, I, \alpha)\) es una inserción de Galois.</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org68e822a" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org68e822a">Ejemplo: simple inferencia de "tipos" (cont.)</h2>
<ul>
<li>Versión abstracta de \(T_P\) (después de alguna simplificación): \[T_P
  \alpha: S^* \rightarrow S^*\]</li>

</ul>

<p>
\(T^\alpha_P(D) = \{p \in S | \exists C \in P, 
                     C = h \rightarrow b_1, \ldots, b_n, \\
                     pred(h) \leftarrow pred(b_1), \ldots , pred(b_n)
                     \equiv p \leftarrow p_1,\ldots , p_n, \\
                     \mbox{ y } p_1,\ldots , p_n \in D\}\)
</p>
<ul>
<li>\(S^*\) finito (número finito de símbolos de predicado en el programa)
y \(T^\alpha_P\) monótona \(\to\) El análisis terminará en un número
finito de pasos \(n\) y \(H^\alpha = T^\alpha_P \uparrow n\) se aproxima a \(H\).</li>

</ul>


<div class="slide-footer"></div>
</section>
<section id="slide-org0e2fcda" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org0e2fcda">Ejemplo: simple inferencia de "tipos" (cont.)</h2>
<ul>
<li>Ejemplo:</li>

</ul>

<p>
\[P = \{p(f(X)) \leftarrow p(X). 
    p(a). 
    r(X) ← t(X,Y). 
    q(a). 
    q(b). \}\]
</p>

<p>
\[P_\alpha = \{p \leftarrow p. 
    p. 
    r ← t. 
    q.\} \]
</p>

<ul>
<li>\(S = \{p/1, q/1, r/1, t/2\}\)</li>

<li>Abstracción: \(\alpha(\{p(a), p(b), q(a)\}) = \{p/1, q/1\}\)</li>

<li>Concretización:</li>

</ul>
<div>
\begin{align}
\gamma(\{p/1, q/1\}) &= \{A \in B | pred(A) = p/1 \vee pred(A) = q/1\} \\
&= \{p(a), p(b), p(f(a)), p(f(b)),\ldots, q(a), q(b), q(f(a)),\ldots \} \\
\end{align}

</div>

<ul>
<li>Análisis:</li>

</ul>
<p>
\(T^\alpha_P \uparrow 0 = T^\alpha_P(\emptyset) = {p / 1, q / 1}\) <br>
\(T^\alpha_P \uparrow 1 = T^\alpha_P(\{p/1, q/1\}) = \{p/1, q/1\} = T^\alpha_P \uparrow 0 = H^\alpha\)
</p>


<div class="slide-footer"></div>
</section>
<section id="slide-org2d6cb22" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org2d6cb22">Análisis <b>bottom up</b> basado en \(T_P\): Discusión</h2>
<ul>
<li>Ventajas:
<ul>
<li>Simple y elegante. Basado en la semántica declarativa de punto fijo</li>
<li>General: resultados independientes de la consulta</li>

</ul></li>
<li>Desventajas:
<ul>
<li>Información solo sobre "salida del procedimiento". Normalmente se
necesita información en varios puntos del programa en la compilación, por ejemplo, "patrones de llamada"</li>
<li>La “variable lógica” no es observada (usa datos
instanciados). Información sobre estado de instanciación,
sustituciones, etc. a menudo necesarios en la compilación</li>
<li>No dirigido a consultas: analiza el programa completo, no la parte
(y los modos) que corresponden al uso "normal" (expresado a través
de una consulta)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org9360cab" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="org9360cab">Análisis <b>Top down</b> (resumido)</h2>
<ul>
<li class="fragment roll-in">Definir una semántica concreta extendida (recolectora), derivada de
la resolución SLD, haciendo observable la información relevante.</li>
<li class="fragment roll-in">Dominio abstracto: generalmente "sustituciones abstractas".</li>
<li class="fragment roll-in">Operaciones abstractas: unificación, composición, proyección, extensión, &#x2026;</li>
<li class="fragment roll-in">Función semántica abstracta: toma una forma de consulta (abstracción
del objetivo inicial o conjunto de metas iniciales) y el programa y
devuelve descripciones abstractas de la sustituciones en puntos relevantes del programa.</li>
<li class="fragment roll-in">Las variables complican las cosas:
<ul>
<li>corrección (debido al aliasing),</li>
<li>terminación (fusión de información relacionada con diferentes cambios de nombre de una variable)</li>

</ul></li>
<li class="fragment roll-in">Las variables lógicas son, de hecho, punteros (que se comportan
bien): 
X = tree(N,L,R),L = nill, Y = N, Y = 3, &#x2026;</li>

<li class="fragment roll-in">esto hace que el análisis de programas lógicos sea muy interesante (y bastante relevante para otros paradigmas).</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgafa5a08" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="orgafa5a08">Arbol AND-OR abstracto</h2>
<ul>
<li>Exploración del árbol <code>?- p.   h:- p1, ... pn.</code>
<img src="arbolandor2.png" alt="arbolandor2.png"></li>
<li>Operacons Basicas:
<ul>
<li>Procedure entry: de \(\lambda_{call}\) obtiene \(\beta1_{entry}\)</li>
<li>Entry-to-exit (b): de \(\beta1_{entry}\) obtiene \(\beta1_{exit}\)</li>
<li>Clause entry: de \(\beta1_{entry}\) obtiene \(\lambda_1\)     (y clause exit)</li>
<li>Body traversal: de \(\lambda_1\) obtiene \(\lambda_{n+1}\)  (iterativamente aplicando (a))</li>
<li>Procedure exit: de (each or all of the) \(\beta{i}_{exit}\) obtiene \(\lambda_{success}\)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgbc9f53c" data-background="" data-background-size="" data-background-position="" data-background-repeat="" data-background-transition="">
<div class="slide-header"></div>
<h2 id="orgbc9f53c">Optimización de Punto Fijo</h2>
<ul>
<li>Punto fijo es requerido solo en los predicados recursivos:</li>

</ul>

<figure>
<img src="arbolrec2.png" alt="arbolrec2.png">

</figure>
<ul>
<li>Recursivo simple (a)</li>
<li>Mutuamente Recursivos (b)
 "Usa la sustitución de exito actual e itera hasta que el punto fijo
es alcanzado"</li>

</ul>
<div class="slide-footer"></div>
</section>
</section>
</div>
</div>
<script src="../reveal.js-master/lib/js/head.min.js"></script>
<script src="../reveal.js-master/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js-master/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js-master/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js-master/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js-master/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js-master/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
,});
</script>
</body>
</html>
