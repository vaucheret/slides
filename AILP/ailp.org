#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_overview:t
#+OPTIONS: reveal_progress:t reveal_rolling_links:nil
#+OPTIONS: reveal_single_file:nil reveal_slide_number:"c" num:nil
#+OPTIONS: reveal_title_slide:auto reveal_width:-1
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js-master
#+REVEAL_TRANS: default
#+REVEAL_SPEED: default
#+REVEAL_THEME: league
#+REVEAL_EXTRA_CSS:
#+REVEAL_EXTRA_JS:
#+REVEAL_HLEVEL: 
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_POSITION:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_SIZE:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_POSITION:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_SLIDE_HEADER:
#+REVEAL_SLIDE_FOOTER:
#+REVEAL_PLUGINS:
#+REVEAL_DEFAULT_FRAG_STYLE:
#+REVEAL_INIT_SCRIPT:
#+REVEAL_HIGHLIGHT_CSS: %r/lib/css/zenburn.css

#+TITLE: Interpretación Abstracta de Programas Logicos
#+DATE: Primera Parte 
#+AUTHOR: Claudio Vaucheret
#+EMAIL: cv@fi.uncoma.edu.ar

# #+REVEAL: split

* Introducción

#+ATTR_REVEAL: :frag (roll-in)
 * analisis / sintesis de programas (Ciencias de la Computación)

 * Probar que un programa $P$ tiene tal propiedad (analisis de programas)

 * Alternativamente: Derivar propiedades que tiene el programa $P$

 * Dado Un programa $P$, generar un programa $P'$ que sea:

   - en algún sentido equivalente a P

   - funcione mejor que $P$ con respecto a algún criterio
   (analisis / sintesis de programas)

 * Aproximación Estandard:
   - identificar que ocurre algún invariante y
   - especializar el programa para el caso particular

* Analisis de Programas

#+ATTR_REVEAL: :frag (roll-in)
 * Frecuente en compiladores aunque raramente tratados en modo formal:
   * "optimización de código"
   * "eliminación de codigo muerto"
   * "movimiento de código"
   * ...
 * Interpretación Abstracta provee un marco formal para desarrollar
   herramientas de análisis de programas
 * Fase de Análisis + fase de sintesis ≡ Interpretación Abstracta +
   Transformación de Programas


* ¿Qué es la Interpretación Abstracta?

#+ATTR_REVEAL: :frag (roll-in)
 - Considere detectar que una rama no ocurre: 
   #+BEGIN_SRC C 
   int x,y,z; y:=read(file); x:= y * y;
   if x >= 0 then z := 1 else z:= 0
   #+END_SRC
   - Analisis Exhaustivo en el dominio estandard: no termina
   - Razonamiento humano de los programas - Usa abstracciones o
     aproximaciones: signos, ordenes de magnitud, par/impar, ...
   - Idea Básica: usar representaciones /aproximadas/ (generalmente
     finitas) de los objetos computacionales para hacer tratable el
     problema del analisis del flujo del programa
 - Analisis Abstracto es la formalización de esta idea:
   - define una semantica no estandard que puede aproximar el
     /significado/ o /funcionamiento/ del programa en un modo finito
   - las expresiones son computadas en un dominio (abstracto)
     aproximado en lugar del dominio concreto.

* Ejemplo: La regla de los signos

#+ATTR_REVEAL: :frag (roll-in)
- Consideremos el dominio $D = Z$ (enteros)
- y el operador de multiplicación: $* : Z^2 \to Z$
- Definimos un *dominio abstracto*: $D_\alpha = \{[-],[+]\}$
- y la multiplicación abstracta $*_\alpha : {D_\alpha}^2 \to D_\alpha$
  definido por: 
               | $*_\alpha$ | $[-]$ | $[+]$ |
               |------------+-------+-------|
               | $[-]$      | $[+]$ | $[-]$ |
               | $[+]$      | $[-]$ | $[+]$ |
               |------------+-------+-------|
- Esto nos permite razonar, por ejemplo, que $y=x^2=x*x$ nunca es negativo
- Algunas observaciones:
  - si tenemos $z = x * y$ entonces:
    si $x,y \in Z$ se aproxima con $x_\alpha, y_\alpha \in
    D_\alpha$ entonces $z \in Z$ se aproxima con $z_\alpha = x_\alpha * y_\alpha$
  - Es importante formalizar esta noción de aproximación para poder
    probar que un análisis es correcto
  - La computación aproximada es generalmente menos precisa pero mas rápida.

 


* Ejemplo: La regla de los signos (cont.)

#+ATTR_REVEAL: :frag (roll-in)
- De nuevo $D = Z$ (enteros)
- y  $* : Z^2 \to Z$
- Definimos un /mas refinado/ *dominio abstracto*: $D'_\alpha = \{[-],[0],[+]\}$
- y la multiplicación abstracta $*_\alpha : {D'_\alpha}^2 \to D'_\alpha$
  definido por: 
               | $*_\alpha$ | $[-]$ | $[0]$ | $[+]$ |
               |------------+-------+-------+-------|
               | $[-]$      | $[+]$ | $[0]$ | $[-]$ |
               | $[0]$      | $[0]$ | $[0]$ | $[0]$ |
               | $[+]$      | $[-]$ | $[0]$ | $[+]$ |
               |------------+-------+-------+-------|
- Esto nos permite razonar, que $z=y*(0*x)$ es cero
- Algunas observaciones:
  - Hay un grado de libertad en definir operadores abstractos y
    dominios diferentes
  - El requerimiento mínimo es que sea *seguro* o *correcto*
  - Definiciones "seguras" diferentes llevan a clase de análisis diferentes


* Ejemplo: La regla de los signos (cont.)

#+ATTR_REVEAL: :frag (roll-in)
- De nuevo $D = Z$ (enteros)
- y el operador de /suma/ $+ : Z^2 \to Z$
- No podemos usar: $D'_\alpha = \{[-],[0],[+]\}$ porque no sabríamos
  como representar el resultado de $[+] +_\alpha [-]$ (i.e. la suma
  abstracta no sería cerrada)
- Un nuevo elemento "$\top$" (supremum) que es la aproximación para todo entero
- Nuevo *dominio abstracto*: $D''_\alpha = \{[-],[0],[+],\top\}$
- suma abstracta $+_\alpha : {D''_\alpha}^2 \to D''_\alpha$
  definido por: 
               | $+_\alpha$ | $[-]$  | $[0]$  | $[+]$  | $\top$ |
               |------------+--------+--------+--------+--------|
               | $[-]$      | $[-]$  | $[-]$  | $\top$ | $\top$ |
               | $[0]$      | $[-]$  | $[0]$  | $[+]$  | $\top$ |
               | $[+]$      | $\top$ | $[+]$  | $[+]$  | $\top$ |
               | $\top$     | $\top$ | $\top$ | $\top$ | $\top$ |
               |------------+--------+--------+--------+--------|
- Esto nos permite ahora razonar que $z=x^2 + y^2$ nunca es negativo

* Observaciones Importantes

#+ATTR_REVEAL: :frag (roll-in)
- Además de la imprecisión debido a la "tosquedad" o lo "básico" de
  $D_\alpha$, las versiones abstractas de las operaciones
  (que dependen de  $D_\alpha$) pueden introducir mas imprecisión
- Así, la elección del /dominio abstracto/ y la definición de las
  /operaciones abstractas/ son cruciales.

 
* Propiedades de la Interpretación Abstracta
#+ATTR_REVEAL: :frag (roll-in)
- Requeridas:
  - Exactitud - aproximaciones correctas: a causa de que las
    propiedades mas "interesantes" son indecidibles el análisis
    necesariamente tiene que ser aproximado. Queremos asegurarnos de
    que el análisis es "conservador" y se equivoca en el "lado seguro"
  - Terminación - la compilación definitivamente debe terminar 
- Deseable - "en la práctica"
  - Eficiencia: en la práctica, el tiempo de análisis finito no es
    suficiente: finito y pequeño
  - Precisión - de la información recopilada: depende de la idoneidad
    de el dominio abstracto y el nivel de detalle al que el
    procedimiento de interpretación imita la semántica del lenguaje
  - Utilidad: determina qué información vale la pena recopilar

* Aproximaciones Correctas 
#+ATTR_REVEAL: :frag (roll-in)
- Idea básica en aproximación: para alguna propiedad $p$ queremos mostrar
         $$\forall x, x \in S \Rightarrow p(x)$$ 
   Alternativa: construir un conjunto $S_a \supseteq S$ y demostrar
        $$\forall x, x \in S_a \Rightarrow p(x)$$ 
   entonces, $S_a$ es una aproximación segura de $S$
- Aproximación de funciones: para alguna propiedad $p$ queremos mostrar 
             $$\forall x, x \in S \Rightarrow p(F(x))$$ 
-  Una función
         $$G: S \rightarrow S$$ es una aproximación segura de $F$ si
         $$\forall x, x \in S, p(G(x)) \Rightarrow p(F(x))$$ 

* Aproximación del significado de un programa

#+ATTR_REVEAL: :frag (roll-in)
- El significado de un programa $P$ es un mapeo $F_P$ de entrada a
  salida, cuyos valores de  entrada y salida $\in$ a un dominio
  "estándar" $D$: $$F_P: D \rightarrow D$$
- "Levantemos" este significado para asignar conjuntos de entradas a
  conjuntos de salidas $$F^*_P: \wp(D) \rightarrow \wp(D)$$ donde $\wp(S)$
  denota el conjunto potencia de S, y $$F_P^*(S) = \{F_P(x) \arrowvert x \in  S\}$$
- Una función $$G: \wp(D) \rightarrow \wp(D)$$ es una aproximación segura de
  $F_P^*$ si  $$\forall S, S \in \wp(D), G(S) \supseteq F_P^*(S)$$
- Las propiedades se pueden demostrar usando $G$ en lugar de $F_P^*$

* Aproximación del significado de un programa (cont.)

#+ATTR_REVEAL: :frag (roll-in)
- Para alguna propiedad $p$ queremos mostrar que para algunas
  entradas - $S, p(F_P^*(S))$
- mostramos que para algunas entradas $S_a, p(G(S_a))$
- Dado que $G(S_a) \supseteq F_P^*(S_a)$ para algunas entradas $S_a, p(F_P^*(S_a))$
        (Nota: abuso de notación - $F_P^*$ no funciona con valores abstractos $S_a$)
- Siempre que $F_P^*$ sea monótono: $$S_a \supseteq S \Rightarrow F_P^*(S_a) \supseteq F_P^*(S)$$
- Y como $S_a \supseteq S$, entonces: para algunas entradas $S, p(F_P^*(S))$


* Dominio abstracto y función de concretización

#+ATTR_REVEAL: :frag (roll-in)
- El dominio $\wp(D)$ se puede representar mediante un dominio
  "abstracto" $D_\alpha$ de representaciones finitas de (posiblemente) objetos infinitos en $\wp(D)$
- La representación de $\wp(D)$ por $D_\alpha$ se expresa mediante una
  función (monótona) llamada función de concretización: $$\gamma :
  D_\alpha → \wp(D)$$ tal que $\gamma(\lambda) = d$ si $d$ es el
  elemento más grande (bajo $\supseteq$) de $\wp(D)$ que $\lambda$
  describe [$(\wp(D), \supseteq)$ es obviamente una retículo completo]

   p.ej. en el ejemplo de los "signos", con $D_\alpha =
  \{[-],[0],[+],\top \}$, $\gamma$ viene dado por \[
  \begin{align}
     \gamma([-]) &= \{x \in Z \arrowvert x < 0  \} \\
     \gamma([0]) &= \{0\} \\
     \gamma([+]) &= \{x \in Z \arrowvert x > 0\} \\
     \gamma(\top) &= Z \\
     \end{align} \]
- $\gamma(?) = \emptyset \rightarrow$ definimos $\bot \arrowvert \gamma(\bot) = \emptyset$

* Función de abstracción

 También podemos definir (no estrictamente necesario) una función de
  abstracción (monótona) $$\alpha : \wp(D) \rightarrow D_\alpha$$
  $\alpha(d) = \lambda$ si $\lambda$ es el elemento "mínimo" de
  $D_\alpha$ que describe $d$ [bajo un orden adecuado definido en los
  elementos de $D_\alpha$] 

   p.ej. en el ejemplo de los "signos", \[
  \begin{align}
       \alpha(\{1, 2, 3\}) &= [+] (no \top) \\
       \alpha(\{- 1, −2, −3\}) &= [-] (no \top) \\
       \alpha(\{0\}) &= [0] \\
       \alpha(\{- 1, 0, 1\}) &= \top \\
     \end{align} \]
     [[file:alphagamma2.png]]


* Significado abstracto y seguridad
- Ahora podemos definir una función de significado abstracto como
  $$F_\alpha : D_\alpha \rightarrow D_\alpha$$ que es segura si
  $$\forall \lambda, \lambda \in D_\alpha, \gamma(F_\alpha(\lambda))
  \supseteq F^*_P(\gamma(\lambda))$$
             [[file:absmean2.png]]
-  Entonces podemos probar una propiedad de la salida de una clase
  dada de entradas representadas por $\gamma$ probando que todos los
  elementos de $\gamma(F_\alpha(\lambda))$ tienen tal propiedad 
- P.ej. en nuestro ejemplo, una propiedad como "si este programa toma
  un número positivo producirá un número negativo como salida" puede
  demostrarse



* Demostrar propiedades en abstracto
#+ATTR_REVEAL: :frag (roll-in)
- Generando $F_\alpha$:
  - $F_P$ obtenido del programa y la semántica predefinida de
    operadores $(x + z) ∗ 3$, $F_P = (x + z) ∗ 3$
  - Análisis automático: $F_\alpha$ debería obtenerse del programa y
    la semántica de operadores abstractos (propiedades compositivas)
    $\{odd, even, +_\alpha, ∗_\alpha\} \Rightarrow F_\alpha = (x +_\alpha z) ∗_\alpha odd$
- "Si este programa toma un número positivo, producirá un número
    negativo como salida"
#+ATTR_REVEAL: :frag (roll-in)
 - $P = (y := x ∗ −3)$, entrada $x$, salida $y$
 - $F_P = x ∗ −3$
 - $F_\alpha = x ∗_\alpha [-]$
 - $F_\alpha([+]) = [+] ∗_\alpha [-] = [-]$

* Semánticas Colectoras
#+ATTR_REVEAL: :frag (roll-in)
- La semántica de "entrada-salida" es a menudo demasiado tosca para un
  análisis útil: información sobre el "Estado" en los puntos de
  programa generalmente requieren $\to$ "semánticas extendidas"
- Los puntos del programa se pueden alcanzar muchas veces, desde
  diferentes puntos y en diferentes "Estados" $\to$ "semanticas
  colectoras" 
     $$\{x> 3\} y := x ∗ −3 \{y < −9 \} \mbox{ o } \{x < −3\} y := x ∗ −3 \{y > 9 \}$$ 
     $$\{x = [+]\} y := x ∗ −3 \{y = [-]\} \mbox{ o } \{x = [-]\} y := x ∗ −3 \{y = [+]\}$$
- El análisis a menudo calcula una colección de estados abstractos
  para un punto de programa.  $$\{x = \{[+], [-]\}\} y := x ∗ −3 \{y = \{[-], [+]\}\}$$
- A menudo, es más eficiente "resumir" estados en uno que ofrezca la
  mejor descripción $\to$  estructura de retículo en un dominio abstracto $$\{x = \sqcup \{[+], [-]\}\} y := x ∗ −3 \{y = \sqcup \{[-], [+]\}\}$$

* Estructura de Retículo
#+ATTR_REVEAL: :frag (roll-in)
- El ordenamiento en $\wp(D), \subseteq$, induce un ordenamiento en
  $D_\alpha, \leq_\alpha$ ("se aproxima mejor") Por ejemplo, podemos
  elegir $\alpha(\{1, 2, 3\}) = [+] \mbox{ o } \alpha(\{1, 2, 3\}) =
  \top$, pero $\gamma([+]) = \{x \in Z \arrowvert x > 0\} \mbox{ y }
  \gamma(\top) = Z$, y dado que $\{x \in Z \arrowvert x > 0\}
  \subseteq Z$ tenemos  $[+] \leq_\alpha \top$, es decir, $[+]$ se
  aproxima mejor que $\top$, es mas preciso.
- Generalmente se requiere que $(D_\alpha, \leq_\alpha)$ sea una retículo completo
- Por lo tanto, para todo $S \subseteq D_\alpha$ existe un único
  mínimo límite superior $\sqcup S \in D_\alpha$, es decir, tal que
  - $\forall \lambda_S \in S, \lambda_S \leq_\alpha \sqcup S$
  - $(\forall \lambda_S \in S, \lambda_S \leq_\alpha \lambda) \Rightarrow \sqcup S \leq_\alpha \lambda$
- Intuición: dado un conjunto de aproximaciones del "estado actual" en
  un punto dado en un programa, para asegurarse de que sea la mejor
  descripción "general" para el punto:
  - $\sqcup S$ se aproxima a /todos/ los elementos de $S$
  - $\sqcup S$ es la mejor aproximación en $D_\alpha$

* Ejemplo: aritmética entera de signos
#+ATTR_REVEAL: :frag (roll-in)
- Consideramos $D_\alpha = \{[-], [0], [+],\top\}$
#+ATTR_REVEAL: :frag (roll-in)
  - Agregamos $\bot$ (infimum) para que $\alpha(\emptyset)$ exista y
    para tener una retículo completo: $D_\alpha = \{\bot, [-], [0],
    [+], \top\}$
  - (Intuición: representa un punto del programa que nunca será alcanzado)
  - La función de concretización debe ampliarse con $$\gamma(\bot) =
    \emptyset$$
  - El reticulo es:
     [[file:reticulo2.png]]
  - $\sqcup\{[+],[-]\} = \sqcup\{[-],[+]\} = \top$

* Ejemplo: aritmética entera de signos (cont.)
- Para hacer $t$ mas significativo, consideramos $D_\alpha = \{\bot,[-],[0^-],[0],[0^+],[+],\top\}$ 
| $\gamma(\bot)$  | $=$ | $\emptyset$                        | $\gamma(\top)$  | $=$ | $Z$                                |                       |
| $\gamma([-])$   | $=$ | $\{x \in Z \arrowvert x < 0 \}$    | $\gamma([+])$   | $=$ | $\{x \in Z \arrowvert x > 0 \}$    | $\gamma([0]) = \{0\}$ |
| $\gamma([0^-])$ | $=$ | $\{x \in Z \arrowvert x \leq 0 \}$ | $\gamma([0^+])$ | $=$ | $\{x \in Z \arrowvert x \geq 0 \}$ |                       |
- El reticulo es: [[file:reticext2.png]]
- $\sqcup\{[-],[0]\} = [0^-]$ representa con precisión un punto del programa donde una variable puede ser negativa o cero


* El enfoque de la inserción de Galois
- A continuación, nos referiremos a $\wp(D)$ simplemente como $D$
- Las semánticas (colectoras) de los programas a menudo son dadas por
  $lfp(F)$ (el mínimo $S$ tal que $S = F(S)$, Siendo $F$ la función
  semántica dependiente del programa en $D$)
- Por lo tanto, necesitamos relacionar este punto fijo con (el de) la
  función semántica aproximada $F_\alpha$ (que se aproxima a $F$ y
  opera sobre los elementos de un dominio abstracto $D_\alpha$)
- Suponga: $D$ y $D_\alpha$ son retículos completos; $\gamma :
  D_\alpha \rightarrow D$ y $\alpha : D \rightarrow D_\alpha$ son
  funciones monotónicas. La estructura $(D_\alpha, \gamma, D, \alpha)$
  se denomina /inserción de Galois/ si:
  - $\forall \lambda \in D_\alpha . \lambda = \alpha(\gamma(\lambda))$
  - $\forall d \in D . d \subseteq \gamma(\alpha(d))$
- La /Aproximación segura/, definida ahora en términos de una
  inserción de Galois: Sea una inserción de Galois $(D_\alpha,
  \gamma,D, \alpha), \lambda \in D_\alpha$ aproxima en forma segura a
  $d \in D$  ssi $d \subseteq \gamma(\lambda)$
- Teorema fundamental [Cousot]: Dada una inserción de Galois
  $(D_\alpha, \gamma, D, \alpha)$ y dos  funciones (monótonas) $F: D
  \rightarrow D$ y $F_\alpha: D_\alpha \rightarrow D_\alpha$ entonces
  si $F_\alpha$ se aproxima a $F$, $lfp(F_\alpha)$ se aproxima a $lfp(F)$

* Terminación: condiciones en $F_\alpha$ y $D_\alpha$
#+ATTR_REVEAL: :frag (roll-in)
- La pregunta es si $lfp(F_\alpha)$ es finitamente computable
- El operador abstracto $F_\alpha$ opera sobre los elementos de un
  dominio abstracto $D_\alpha$, que hemos requerido que sea un
  retículo completo, y $F_\alpha$ es monótona, por lo tanto
  $$lfp(F_\alpha) = F_\alpha \uparrow n$$ para algún $n$ que nos
  gustaría sea finito (es decir, nos gustaría que la secuencia de Kleene fuera finita)
- Recordando las características de los puntos fijos en retículos, la
  secuencia de Kleene será finito en casos que incluyen:
  - $D_\alpha$ es finito
  - $D_\alpha$ es cadena ascendente finita

 
* Estructura de Retículos

| finito                | cadena finita ascendente |
| [[file:finito2.png]]      | [[file:chain2.png]]          |
| finito en profundidad |                          |
| [[file:finitedepht2.png]] |                          |

