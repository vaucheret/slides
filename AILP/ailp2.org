#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_overview:t
#+OPTIONS: reveal_progress:t reveal_rolling_links:nil
#+OPTIONS: reveal_single_file:nil reveal_slide_number:"c" num:nil
#+OPTIONS: reveal_title_slide:auto reveal_width:-1
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js-master
#+REVEAL_TRANS: default
#+REVEAL_SPEED: default
#+REVEAL_THEME: league
#+REVEAL_EXTRA_CSS:
#+REVEAL_EXTRA_JS:
#+REVEAL_HLEVEL: 
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_POSITION:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_SIZE:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_POSITION:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_DEFAULT_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_SLIDE_HEADER:
#+REVEAL_SLIDE_FOOTER:
#+REVEAL_PLUGINS:
#+REVEAL_DEFAULT_FRAG_STYLE:
#+REVEAL_INIT_SCRIPT:
#+REVEAL_HIGHLIGHT_CSS: %r/lib/css/zenburn.css

#+TITLE: Interpretación Abstracta de Programas Logicos
#+DATE: Segunda Parte 
#+AUTHOR: Claudio Vaucheret
#+EMAIL: cv@fi.uncoma.edu.ar


* Análisis de programas lógicos
#+ATTR_REVEAL: :frag (roll-in)
- ¿Qué semántica?
  - Semántica declarativa: relacionada a qué es una consecuencia del programa
    - Semántica de la teoría de modelos mínimos
    - Semántica de punto fijo (basada en el operador $T_P$)
      (cf. estilo de base de datos, evaluación bottom-up )
  - Semántica operativa: cercana al comportamiento del programa
    - Basado en resolución SLD (conjuntos éxitosos)
    - Denotacional
    - Puede cubrir posibilidades distintas a SLD: reactivo, paralelo, ...
- Los análisis basados en semántica declarativa a menudo se denominan análisis *bottom up*
- Los análisis basados en la semántica operativa (de arriba hacia
  abajo) a menudo se denominan Análisis *top down*
- Además, casos intermedios (generalmente logrados mediante la
  transformación de programas) 


* Caso de Estudio: Semántica de punto fijo
#+ATTR_REVEAL: :frag (roll-in)
- Dado el lenguaje de primer orden $L$ asociado con un programa $P$
  dado, el universo de Herbrand ($U$) es el conjunto de todos los
  términos básicos de $L$.
- La Base de Herbrand ($B$) es el conjunto de todos los átomos
  instanciados (/ground/) de $L$.
- Una /interpretación de Herbrand/ es un subconjunto de $B$. $I$ es el
  conjunto de todas las interpretaciones de Herbrand ($\wp(B)$)
- Un /modelo de Herbrand/ es una interpretación de Herbrand que contiene
  todos las consecuencias del programa.
- El operador de consecuencia inmediata ($T_P$) es un mapeo $T_P : I
  \rightarrow I$ definido por: $$T_P(M) = \{h \in B \vert \exists C
  \in ground(P), C = h \leftarrow b_1, \ldots, b_n \mbox{ y } b_1, \ldots,
  b_n \in M\}$$ (en particular, si ($a \leftarrow$) \in $P$, entonces $ground(a) \subseteq T_P(M)$, para cada $M$).
- $T_P$ es monótono, por lo que tiene un minimo punto fijo $lfp(T_P)$
  que se puede obtener como $T_P \uparrow \omega$ comenzando desde el
  elemento inferior del retículo (la interpretación vacía, $\emptyset$).
- (Teorema de caracterización) [Van Emden y Kowalski]: El menor modelo de Herbrand $P$, $H$ es $lfp(T_P)$

* Semántica de punto fijo: Ejemplo

$P = \{ p(f(X)) \leftarrow p(X). \\
        p(a). \\
        q(a). \\
        q(b). \}$

\begin{align}
U &= \{ a,b,f(a),f(b),f(f(a)),f(f(b)),\ldots \} \\

B &= \{ p(a),p(b),q(a),q(b),p(f(a)),p(f(b)),p(f(f(a))),p(f(f(b))),q(f(a))\ldots  \} \\

I &= \mbox{ todos los subconjuntos de } B \\

H &= \{ q(a), q(b), p(a), p(f(a)), p(f(f(a))), \ldots \} \\
\end{align}      

\begin{align}
T_P \uparrow 0 &= \{ p(a),q(a),q(b) \}\\

T_P \uparrow 1 &= \{ p(a),q(a),q(b),p(f(a)) \} \\

T_P \uparrow 2 &= \{ p(a),q(a),q(b),p(f(a)),p(f(f(a))) \} \\

\ldots \\

T_P \uparrow \omega &= H \\
\end{align}      


* Interpretación abstracta "Bottom up"
- Encuentra una aproximación de $H$ al aproximar $lfp(T_P)$
- Aplicamos interpretación abstracta:
  - Dominio: $I^\alpha$, tal que elementos de $I^\alpha$ aproxima elementos de $I = \wp(B)$.
  - Función de concretización: $\gamma: I^\alpha \rightarrow I$
  - Función de abstracción: $\alpha: I \rightarrow I^\alpha$
  - Operador Abstracto: versión abstracta del operador $T_P$  $T^\alpha_P : I^\alpha \rightarrow I^\alpha$
  - Exactitud:
    - $(I^\alpha, \gamma, I, \alpha)$ debe ser una inserción de
      Galois, es decir, $I^\alpha$ retículo completo y debería
      aproximar a $I: \forall M \in I, \gamma(\alpha(M)) \supseteq M$
    - $T^\alpha_P$ aproximación segura de $T_P$, es decir, $\forall d,
      d \in  I^\alpha, \gamma(T^\alpha_P(d)) \supseteq T_P(\gamma(d))$
  - Terminación:
    - $T^\alpha_P$ es monótono.
    - $I^\alpha$ (al menos) cadena ascendente finita.
- Entonces, $H^\alpha = lfp(T^\alpha_P) = T^\alpha_P \uparrow n$ se
  obtendrá en un número finito de pasos $n$ y $H^\alpha$ se aproximará a $H$.

* Interpretación abstracta "Bottom up" (cont.)

[[file:bottomup2.png]]


* Ejemplo: simple inferencia de "tipos" 
- Problema de "inferencia de tipo" mínimal [Sondergaard]: Aproximación
  de qué predicados están en $H$
- $pred(a):$ denota el símbolo de predicado de un átomo $a$
- $B^\alpha = S$ (conjunto de símbolos de predicado en un programa
  $P$) Entonces $I^\alpha = \wp(S)$, lo llamamos $S^*$
- Función de concretización:
  - $\gamma: S^* \rightarrow I$
  - $\gamma(D) = \{a \in B | pred(a) \in D \}$
- Función de abstracción:
  - $\alpha: I \rightarrow S^*$
  - $\alpha(M) = \{p \in S | \exists a \in M, pred(a) = p \}$
- $(S^*, \gamma, I, \alpha)$ es una inserción de Galois.

* Ejemplo: simple inferencia de "tipos" (cont.)
- Versión abstracta de $T_P$ (después de alguna simplificación): $$T_P
  \alpha: S^* \rightarrow S^*$$ 

$T^\alpha_P(D) = \{p \in S | \exists C \in P, 
                     C = h \rightarrow b_1, \ldots, b_n, \\
                     pred(h) \leftarrow pred(b_1), \ldots , pred(b_n)
                     \equiv p \leftarrow p_1,\ldots , p_n, \\
                     \mbox{ y } p_1,\ldots , p_n \in D\}$
- $S^*$ finito (número finito de símbolos de predicado en el programa)
  y $T^\alpha_P$ monótona $\to$ El análisis terminará en un número
  finito de pasos $n$ y $H^\alpha = T^\alpha_P \uparrow n$ se aproxima a $H$.


* Ejemplo: simple inferencia de "tipos" (cont.)

- Ejemplo:

$$P = \{p(f(X)) \leftarrow p(X). 
    p(a). 
    r(X) ← t(X,Y). 
    q(a). 
    q(b). \}$$

$$P_\alpha = \{p \leftarrow p. 
    p. 
    r ← t. 
    q.\} $$

- $S = \{p/1, q/1, r/1, t/2\}$

- Abstracción: $\alpha(\{p(a), p(b), q(a)\}) = \{p/1, q/1\}$

- Concretización:
\begin{align}
\gamma(\{p/1, q/1\}) &= \{A \in B | pred(A) = p/1 \vee pred(A) = q/1\} \\
&= \{p(a), p(b), p(f(a)), p(f(b)),\ldots, q(a), q(b), q(f(a)),\ldots \} \\
\end{align}

- Análisis:
$T^\alpha_P \uparrow 0 = T^\alpha_P(\emptyset) = {p / 1, q / 1}$ \\
$T^\alpha_P \uparrow 1 = T^\alpha_P(\{p/1, q/1\}) = \{p/1, q/1\} = T^\alpha_P \uparrow 0 = H^\alpha$


* Análisis *bottom up* basado en $T_P$: Discusión
- Ventajas:
  - Simple y elegante. Basado en la semántica declarativa de punto fijo
  - General: resultados independientes de la consulta
- Desventajas:
  - Información solo sobre "salida del procedimiento". Normalmente se
    necesita información en varios puntos del programa en la compilación, por ejemplo, "patrones de llamada"
  - La “variable lógica” no es observada (usa datos
    instanciados). Información sobre estado de instanciación,
    sustituciones, etc. a menudo necesarios en la compilación
  - No dirigido a consultas: analiza el programa completo, no la parte
    (y los modos) que corresponden al uso "normal" (expresado a través
    de una consulta)

* Análisis *Top down* (resumido)
#+ATTR_REVEAL: :frag (roll-in)
- Definir una semántica concreta extendida (recolectora), derivada de
  la resolución SLD, haciendo observable la información relevante.
- Dominio abstracto: generalmente "sustituciones abstractas".
- Operaciones abstractas: unificación, composición, proyección, extensión, ...
- Función semántica abstracta: toma una forma de consulta (abstracción
  del objetivo inicial o conjunto de metas iniciales) y el programa y
  devuelve descripciones abstractas de la sustituciones en puntos relevantes del programa.
- Las variables complican las cosas:
  - corrección (debido al aliasing),
  - terminación (fusión de información relacionada con diferentes cambios de nombre de una variable)
- Las variables lógicas son, de hecho, punteros (que se comportan
  bien): 
  X = tree(N,L,R),L = nill, Y = N, Y = 3, ...

- esto hace que el análisis de programas lógicos sea muy interesante (y bastante relevante para otros paradigmas).

* Arbol AND-OR abstracto
- Exploración del árbol ~?- p.   h:- p1, ... pn.~
  [[file:arbolandor2.png]]
- Operacons Basicas:
  - Procedure entry: de $\lambda_{call}$ obtiene $\beta1_{entry}$
  - Entry-to-exit (b): de $\beta1_{entry}$ obtiene $\beta1_{exit}$
  - Clause entry: de $\beta1_{entry}$ obtiene $\lambda_1$     (y clause exit)
  - Body traversal: de $\lambda_1$ obtiene $\lambda_{n+1}$  (iterativamente aplicando (a))
  - Procedure exit: de (each or all of the) $\beta{i}_{exit}$ obtiene $\lambda_{success}$

* Optimización de Punto Fijo
- Punto fijo es requerido solo en los predicados recursivos:
[[file:arbolrec2.png]]
- Recursivo simple (a)
- Mutuamente Recursivos (b)
   "Usa la sustitución de exito actual e itera hasta que el punto fijo
  es alcanzado"
