#+OPTIONS: reveal_center:t reveal_control:t reveal_height:-1
#+OPTIONS: reveal_history:nil reveal_keyboard:t reveal_overview:t
#+OPTIONS: reveal_progress:t reveal_rolling_links:nil
#+OPTIONS: reveal_single_file:nil reveal_slide_number:t num:nil
#+OPTIONS: reveal_title_slide:t reveal_width:-1
#+REVEAL_MARGIN: -1
#+REVEAL_MIN_SCALE: -1
#+REVEAL_MAX_SCALE: -1
#+REVEAL_ROOT: ../reveal.js-master
#+REVEAL_TRANS: cube
#+REVEAL_SPEED: default
#+REVEAL_THEME: solarized
#+REVEAL_EXTRA_CSS:
#+REVEAL_EXTRA_JS:
#+REVEAL_HLEVEL: 2
#+REVEAL_TITLE_SLIDE_TEMPLATE: <h1>%t</h1><h2>%a</h2><h2>%e</h2><h2>%d</h2>
#+REVEAL_TITLE_SLIDE_BACKGROUND:
#+REVEAL_TITLE_SLIDE_BACKGROUND_SIZE:
#+REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT:
#+REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION:
#+REVEAL_MATHJAX_URL: https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
#+REVEAL_PREAMBLE:
#+REVEAL_HEAD_PREAMBLE:
#+REVEAL_POSTAMBLE:
#+REVEAL_MULTIPLEX_ID:
#+REVEAL_MULTIPLEX_SECRET:
#+REVEAL_MULTIPLEX_URL:
#+REVEAL_MULTIPLEX_SOCKETIO_URL:
#+REVEAL_SLIDE_HEADER:
#+REVEAL_SLIDE_FOOTER:
#+REVEAL_PLUGINS:
#+REVEAL_DEFAULT_FRAG_STYLE:
#+REVEAL_INIT_SCRIPT:

#+TITLE: Conceptos Avanzados en Lenguajes de Programación
#+DATE:  <2016-08-16 mar>
#+AUTHOR: Claudio Vaucheret / Marcelo Amaolo
#+EMAIL: cv@fi.uncoma.edu.ar / marcelo.amaolo@fi.uncoma.edu.ar

* Introducción

** Razones para estudiar Conceptos de Lenguajes de Programación
- Incrementa la habilidad para expresar ideas
- Mejora la capacidad de elegir el lenguaje apropiado
- Incrementa la capacidad de aprender nuevos lenguajes
- Mejora el entendimiento del funcionamiento interno del lenguaje
  (implementación)

** Dominios de Programación
- Aplicaciones Científicas
  - Gran número de computación de punto flotante
  - Fortran
- Aplicaciones Empresariales
  - Producción de Reportes, uso de números decimales y caracteres
  - Cobol
- Inteligencia Artificial
  - Manipulación simbólica (en lugar de números)
  - LISP
- Sistemas de Programación
  - Necesidad de eficiencia (debido al uso continuo)
  - C
- Software para la WEB
  - Colección ecléctica de lenguajes: maukup (e.g. HTML5), scripting
    (e.g. PHP), de propósito general (e.g. Java)

** Criterios de Evaluación de Lenguajes
- *Legibilidad*: la facilidad con la cual los programas pueden ser
  leídos y entendidos.
- *Escribilidad*: la facilidad con la cual un lenguaje puede ser usado
  para crear programas
- *Confiabilidad*: El grado en que el lenguaje funciona de acuerdo a
  sus especificaciones.
- *Costo*: de uso, compilación, mantenimiento etc.

*** Legibilidad
- Simplicidad
  - Un conjunto manejable de características y construcciones
  - Poca multiplicidad de características (medios de realizar la misma operación)
  - Minima sobrecarga de operadores
- Ortogonalidad
  - Un conjunto relativamente pequeño de construcciones primitivas que
    puedan ser combinadas en un numero pequeño de modos
  - Toda posible combinación sea legal.
- Sentencas de Control
  - La presencia de bien conocidas estructuras de control
- Tipos de Datos y Estructuras
  - La presencia de facilidades adecuadas para definir estructuras de datos
- Consideraciones sintácticas
  - Composición flexible de identificadores
  - Palabras especiales y métodos para formar sentencias compuestas
  - Construcciones autodescriptivas, palabras reservadas
    significativas

*** Escribilidad

- Simplicidad y ortogonalidad
  - Pocas constucciones, numero pequeño de primitivas y pocas reglas
    para combinarlas.
- Soporte para la abstracción
  - La habilidad para definir y usar estructuras complejas o
    operaciones de modo que los detalles puedan ser ignorados
- Expresibilidad
  - Un conjunto conveniente de modos de especificar operaciones
  - Ejemplo: La inclusión de la sentencia *FOR* en  muchos lenguajes modernos

*** Confiabilidad

- Chequeo de Tipos
  - verificación de errores de tipos
- Manejo de Excepciones
  - interceptar errores en ejecución y tomar medidas correctivas
- Aliasing
  - Presencia de dos o mas distintas referencias para el mismo lugar
    de memoria
- Legibilidad y Escribilidad
  - Un lenguage que no soporta modos "naturales" de expresar un
    algoritmo necesariamente usará aproximaciones "no naturales" y asi
    reducirá la confiabilidad

*** Costo
- Costo de ...
  + Entrenar programadores para usar un lenguaje
  + Escribir programas (cercano a aplicaciones particulares)
  + Compilar programas
  + Ejecutar programas
  + Implementar Lenguajes (disponibilidad de compiladores libres)
  + Confiabilidad: Confiabilidad pobre lleva a altos costos
  + Mantener programas

*** Otros
- Portabildad
  + La facilidad con que los programas puedan moverse de una
    implementación a otra
- Generalidad
  + Su aplicabilidad a un amplio rango de aplicaciones.
- Bien definido
  + La completitud y precisión de la definición oficial del lenguaje

** Influencias en el diseño de los lenguajes
 - Arquitectura de Computadoras
   + Lenguajes son desarrollados alrededor de la arquitectura de
     computadora prevaleciente, conocida como arquitectura de /von Neumann/
 - Metodologías de Programación
   + Nuevas metodologías de desarrollo de software (e.g. desarrollode
     software orientado a objetos) llevan a nuevos paradigmas y por
     extensión a nuevos lenguajes de programación

*** Influencia de la Arquitectura de Computadoras

- Arquitectura de Computadora bien conocida: Von Neumann
- Lenguajes Imperativos mas dominantes debido a la arquitectura
  dominante
  + Datos y Programas almacenados en memoria
  + Memoria Separada de la CPU
  + Instrucciones y Datos son conducidos desde la Memoria a la CPU
  + Bases para los lenguajes imperativos
    - Variables modelan celdas de memoria
    - La iteración es eficiente

*** Arquitectura de Von Neumann

[[file:vonneumann.png]] 

*** Influencia de las Metodogías de Programación
- Décadas de los 50 y 60: Simples aplicaciones; preocupación principal
  la eficiencia
- Finales de los 60: Eficiencia de programación toma importancia:
  legibilidad, mejores estructuras de control
  + Programación Estructurada
  + Diseño /top-down/ y refinamiento /step-wise/
- Finales de los 70: De Orientación a Procesos a Orientación a Datos.
  + Abstracción de Datos
- Mediados de los 80: Programación orientada a Objetos
  - Abstracción de Datos + Herencia + Polimorfismo

*** Categoría de Lenguajes
- Imperativa
  + Variables, sentencias de asignación e iteración
  + Ejemplos: C, Pascal
- Funcional
  + Principal medio de computación es aplicar funciones a parámetros
  + Ejemplos: LISP, Scheme
- Lógica
  + Basado en Reglas
  + Ejemplo: Prolog
- Orientado a Objetos
  + abstracción de datos, herencia, ligadura tardía
  + Ejemplos: Java, C++
- Marcado
  + No programación per se, pero usados para especificar la
    información mostrada en documentos web
  + Ejemplos: XHTML, XML

*** Compromisos en el diseño de Lenguajes
- Confiabilidad vs. Costo de ejecución
  + Ejemplo: Java exige que todas las referencias a elementos de los
    arreglos sean chequeadas si la indexación es correcta, pero esto
    incrementa el costo de ejecución
- Legibilidad vs. Escribilidad
  + Ejemplo: APL provee muchos operadores poderosos (y un gran numero
    de nuevos simbolos) permitiendo que complejas operaciones sean
    escritas en un programa compacto pero con el costo de pobre legibilidad
- Flexibilidad vs. Confiabilidad
  + Ejemplo: Los punteros de C++ son poderosos y muy flexibles pero de
    un uso poco confiable.

** Métodos de Implementación 
- Compilación
  + Los programas son traducidos al lenguaje máquina
- Interpretación Pura
  + Los programas son interpretados por otro programa llamado intérprete
- Sistemas de implementación híbridos
  + Un compromiso entre compilación y interpretación pura

*** Capas de Implementación de Lenguajes

[[file:interfacecapas.png]]

*** Compilación
- Traduce programas de alto nivel (lenguaje fuente) en codigo máquina
- Traducción lenta, ejecución rápida
- El proceso de compilación tiene varias faces:
  + análisis lexico: convierte caracteres del programa fuente en
    unidades léxicas
  + análisis sintáctico: Transforma unidades léxicas en árboles
    sintácticos /parse trees/
  + análisis semántico: Genera código intermedio
  + generación de código: Codigo máquina es generado

*** El proceso de compilación

[[file:procesocomp.png]] 

*** Terminología Adicional de Compilación

- Módulo de carga (imagen ejecutable) : El código del usuario y del
  sistema juntos
- /linking and loading/ Enlazado y Carga: El proceso de recolectar los
  programas del sistema y enlazarlo al programa del usuario

*** Ejecución del Código Máquina

- ciclo de traer y ejecutar (sobre una arquitectura Von Neumann)

#+BEGIN_SRC pascal
repeat  por siempre
   traer la instrucción apuntada por el contador
   incrementar el contador
   decodificar la instrucción
   ejecutar la instrucción
end repeat
#+END_SRC

*** /Cuello de botella/ de Von Neumann

- La velocidad de conección entre la memoria de la computadora y su
  procesador determina la velocidad de la computadora
- Las intrucciones del programa son ejecutadas mucho mas rápido que la
  velocidad de conección; por lo tanto ésta se vuelve el /cuello de botella/
- Es conocido que /cuello de botella/ de la arquitectura de Von
  Neumann es el principal factor en la velocidad de las computadoras

*** Interpretación Pura
- Sin traducción
- Facil implementación de programas. Errores de tiempo de ejecución
  pueden ser facilmente reconocidos
- Ejecución mas lenta (10 a 100 veces mas lenta que programas compilados)
- Frecuentemente requiere mas espacio
- Se volvio infrecuente en lenguajes de alto nivel
- Han retornado con lenguajes de /sripting/ para la Web (e.g. JavaScript)

*** Proceso de Interpretación Pura

[[file:procesointerppuro.png]]

*** Sistemas de Implementación Híbrida
- Un compromiso entre compilador y intérprete puro
- El programa en lenguaje de alto nivel es traducido a un lenguaje
  intermedio que permite facil interpretación
- Mucho mas rápido que interpretación pura
- Ejemplos
  + Programas en Perl son parcialmente compilados para detectar
    errores antes de la interpretación
  + Implementaciones iniciales de Java fueron híbridas, la forma
    intermedia /byte code/, proveyó portabilidad a toda máquina que
    tenía un interprete de /byte code/ y un sistema de /run time/
    (juntos son llamados la máquina virtual de java)

*** Proceso de Implementación Híbrida

[[file:procesohibrido.png]] 

*** Sistemas de Implementación /Just in Time/
- Inicialmente Los programas se traducen a un lenguaje intermedio
- Luego el lenguaje intermedio se compila a código máquina
- La versión en máquina se conserva para llamadas subsecuentes
- Sistemas JIT son ampliamente usados para programas Java
- Lenguajes .NET son implementados con sistemas JIT

*** Preprocesadores
- Macros de preprocesamiento (instrucciones) son comunmente usadas
  para especificar que código de otros archivos sean incluidos
- Un preprocesador procesa un programa inmediatamente antes de que el
  programa se compilada para expandir las macros incluídas
- Un ejemplo conocido: El preprocesador de C
  + expands #include, #define, y macros similares

*** Entornos de Programación 
- Una colección de herramientas usadas en el desarrollo de software
- UNIX
  + un tradicional sistema operativo y colección de herramientas
  + hoy en dia frecuentemente usado a través de un GUI que corren
    sobre UNIX
- Borland JBuilder
  + Un entorno de programación integrado para Java
- Microsoft Visual Studio .NET
  + Un complejo entorno visual de desarrollo
  + Usado para programar en C#, Visual Basic .NET, jscript, J# o C++
  

* Evolución de los Lenguajes de Programación

** Lenguajes de Programación

[[file:evolleng.png]]

** Evolución de los primeros lenguajes
 #+ATTR_REVEAL: :frag (roll-in)

**  Konrad Zuze's language de la computadora Z4.

*** Zuse's Plankalkül

- Desarrollado en 1945
- Nunca implementado
- Su descripción fue publicada en 1972.
- Tipos de datos: bit, Integer and float tipos compuestos.
- arreglos y registros

#+BEGIN_SRC lisp
  | A + 1 => A
V | 4        5
S | 1.n      1.n
#+END_SRC




** Codigo Máquina: pseudocodigos ¿?

*** Escribir en lenguaje máquina

- poco legibles y modificables
- sin indices ni punto flotante
- direccionamiento absoluto

*** Shorte Code Mauchly (1949) 

- computadora BINAC 
- Expresiones eran codificadas de izquierda a derecha
- Ejemplos de operaciones:

#+BEGIN_SRC lisp
01 - 06 abs value 1n (n+2)nd power
02 ) 07 +         2n (n+2)nd root
03 = 08 pause     4n if <= n
04 / 09 (         58 print and tab
#+END_SRC

La sentencia X0 = SQRT(ABS(Y0)) podria ser codificada como:

#+BEGIN_SRC lisp
00 X0 03 20 06 Y0
#+END_SRC

*** Speedcoding

- Desarrollado por John Backus en 1954 para IBM 701
- Pseudo operaciones para funciones aritméticas y matemtaticas
  - bifurcación condicional e incondicional
  - registros autoincrementales para acceso a arreglos
  - 4.2 millisegundos la instruccion de suma y 700 palabras para el programa
  - 2 semanas de programación en pocas horas!!!

*** Otros sistemas relacionados

- Sistema de "compilación" UNIVAC
  - Desarrollado por el equipo de Brace Hopper
  - Pseudocodigo expandido en código máquina (macros)
- David J Wheeler (Universidad de Cambridge) (1950)
  - Desarrollo un método de usar bloques de direccionamiento reubicables
- Wilkes (1951-1957) desarrollo lenguaje /assembler/ con estas ideas


** IBM 704 y Fortran

*** Fortan 
- Fortran 0: 1954 - no implementado
- Fortran 1 1957
  - Diseñado para la nueva IBM 704, que tenía registros y aritmética
    de punto flotante
  - Entorno de Desarrollo
    - Las Computadoras eran pequeñas y confiables
    - Las aplicaciones eran científicas
    - Sin metodología ni herramientas de programación
    - Importancia en *eficiencia*

*** Proceso de Diseño
- El impacto del entorno en el diseño de Fortran
  - Sin necesidad de almacenamiento dinámico
  - Necesidad de un buen manejo de arreglos y ciclos
  - Sin manejo de cadenas, aritmética decimal o herramientas de
    entrada/salida (de uso comercial)

*** Fortran I
- Primera versión implementada de Fortrand
  - Nombres hasta 6 caracteres
  - Ciclos iterativos con post condición (*DO*)
  - I/O formateada
  - subprogramas definidos por el usuario
  - Sentencias condicionales de tres modos (*IF* aritmético)
  - sentencias sin tipo de datos

*** Fortran I
- Primera versión implementada
  - Sin compilación separada
  - Compilador distribuido en Abril de 1957,
  - Programas de mas de 400 lineas raramente compilaban correctamente,
    principalmente debido a la pobre confiabilidad de la IBM 704
  - La Codificación era verdaderamente rápida
  - Rapidamente se volvió ampliamente usado

*** Fortran II
- Distribuido en 1958
  - Compilación independiente
  - Se corrigieron muchos errores

*** Fortran IV
- Desarrollado durante 1960-1962
  - Declaración explicita de tipos
  - Sentencia de selección lógica
  - Nombres de programas podian se pasados como parámetros
  - ANSI standard en 1966

*** Fortran 77
- Se volvió el nuevo estandard en 1978
  - Manejo de cadenas de caracteres
  - sentencia de control de ciclos lógico
  - sentencia *IF-THEN-ELSE*

*** Fortran 90
- Con los mas significativos cámbios desde el Fortran 77
  - Módulos
  - Arreglos dinámicos
  - Punteros
  - Recursión
  - sentencia *CASE*
  - chequeo de tipos en los parametros

*** Evaluación de Fortran
- Compiladores altamente optimizados (todas las versiones anteriores a 90)
  - Los tipos y almacenamiento de todas las variables eran fijas antes del
    tiempo de ejecución.
- Dramaticamente cambió para siempre el modo en que las computadoras
  fueron usadas
- Caracterizados como la /lingua franca/ del mundo de la computación


** Programación Funcional: LISP

** Primera sofisticación: ALGOL 60

** Aplicaciones Comerciales: COBOL

** Comienzo de tiempo compartido: BASIC 
