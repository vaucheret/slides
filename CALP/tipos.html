<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conceptos Avanzados en Lenguajes de Programación</title>
<meta name="author" content="(Tipos de Datos)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js-master/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js-master/css/theme/solarized.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js-master/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="" data-background-size="" data-background-repeat="" data-background-transition=""><h1 class="title">Conceptos Avanzados en Lenguajes de Programación</h1><h2 class="author">Tipos de Datos</h2><h2 class="date">2016-08-29 lun 00:00</h2><p class="date">Created: 2020-09-06 dom 16:43</p>
</section>
<section id="table-of-contents">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-org115efa0">Introducción</a>
<ul>
<li><a href="#/slide-org732f977">Tipos de Datos</a>
<ul>
<li><a href="#/slide-orgee83142">Tipos de Datos</a></li>
<li><a href="#/slide-orgf742384">Tipos de Datos</a></li>
<li><a href="#/slide-org3c6f48d">Tipos de Datos</a></li>
<li><a href="#/slide-orgc46007d">Sistema de Tipos</a></li>
<li><a href="#/slide-org4d44fb3">Chequeo de Tipos</a></li>
<li><a href="#/slide-orga538d22">Estructural vs. por Nombre</a></li>
</ul>
</li>
<li><a href="#/slide-org0a42195">Chequeo de Tipos: Coerción</a>
<ul>
<li><a href="#/slide-orgedfb21d">Chequeo de Tipos: Coerción</a></li>
<li><a href="#/slide-org35a1552">Chequeo de Tipos: Coerción</a></li>
<li><a href="#/slide-org25427ae">Chequeo de Tipos: Coerción</a></li>
<li><a href="#/slide-org3156d7d">Chequeo de Tipos: Coerción</a></li>
</ul>
</li>
<li><a href="#/slide-orgc32bea0">Arreglos</a>
<ul>
<li><a href="#/slide-orgfcb07ba">Cuestiones de Diseño de Arreglos</a></li>
<li><a href="#/slide-org14ae91b">Accediendo a los elementos del Arreglo</a></li>
<li><a href="#/slide-orge1ff148">Tipos de los subíndices de los arreglos</a></li>
<li><a href="#/slide-orga66a428">Categoría de Arreglos</a></li>
<li><a href="#/slide-org06831d1">Categoría de Arreglos</a></li>
<li><a href="#/slide-orga525d9e">(Stack) Dinámicos fijos</a></li>
<li><a href="#/slide-orga90e953">Arreglos</a></li>
<li><a href="#/slide-orgcddd8bb">Arreglos</a></li>
<li><a href="#/slide-org5c20fca">Arreglos</a></li>
<li><a href="#/slide-org6536819">Arreglos</a></li>
<li><a href="#/slide-orga833303">Inicialización de Arreglos</a></li>
<li><a href="#/slide-orgb8b15d9">Operaciones de Arreglos</a></li>
<li><a href="#/slide-org157c998">Arreglos</a></li>
<li><a href="#/slide-org1d3708e">Slices</a></li>
<li><a href="#/slide-orgb1568d9">Slices</a></li>
<li><a href="#/slide-org8f2747c">Descriptores en Tiempo de Compilación</a></li>
<li><a href="#/slide-org3da4c28">Arreglos Asociativos</a></li>
</ul>
</li>
<li><a href="#/slide-org1c1d8f1">Strings</a></li>
<li><a href="#/slide-orgb7cac06">Tipo Registros</a>
<ul>
<li><a href="#/slide-orgec6f2e4">Tipo Registros</a></li>
<li><a href="#/slide-org18497b6">Registros</a></li>
<li><a href="#/slide-orgc941de7">Operaciónes de Registros</a></li>
<li><a href="#/slide-orga0b5b32">Comparación con Arreglos</a></li>
<li><a href="#/slide-orgbce0a94">Implementación de Registros</a></li>
<li><a href="#/slide-org0aba25f">Tipo Uniones</a></li>
<li><a href="#/slide-orgf200abe">tipo Union de Ada</a></li>
<li><a href="#/slide-org65784a9">Evaluación de Uniones</a></li>
</ul>
</li>
<li><a href="#/slide-org7b392d8">Punteros y Tipos Recursivos</a>
<ul>
<li><a href="#/slide-org9847e2a">Tipo Punteros</a></li>
<li><a href="#/slide-org7b48372">Punteros y Tipos Recursivos</a></li>
<li><a href="#/slide-orgd8bc50a">Punteros y Tipos Recursivos</a></li>
<li><a href="#/slide-org49179a2">Punteros y Tipos Recursivos</a></li>
<li><a href="#/slide-orgcba6f5a">Punteros y Tipos Recursivos</a></li>
</ul>
</li>
<li><a href="#/slide-orgbc38414">Listas</a></li>
<li><a href="#/slide-orge2984b9">Archivos y Entrada/Salida</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</section>

<section>
<section id="slide-org115efa0">
<div class="slide-header"></div>
<h2 id="org115efa0">Introducción</h2>
<div class="outline-text-2" id="text-org115efa0">
</div><div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-org732f977">
<div class="slide-header"></div>
<h3 id="org732f977">Tipos de Datos</h3>
<ul>
<li>Hemos desarrollado una noción intuitiva de tipo de dato; ¿Que hay
detras de la intuición?
<ul>
<li>Conjunto de valores de un "dominio" (la aproximación funcional)</li>
<li>Estructura interna de un manojo de datos, descripto al nivel de un
conjunto pequeño de tipos fundamentales (aproximación estructural)</li>
<li>Clase de equivalencia de objetos (aproximación del implementador)</li>
<li>Conjunto de operaciones bien-definidas que pueden ser aplicadas a
objetos de ese tipo (aproximación de abstracción)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgee83142">
<div class="slide-header"></div>
<h4 id="orgee83142">Tipos de Datos</h4>
<ul>
<li>Utilidad
<ul>
<li>Contexto implícito</li>
<li>Chequeo de tipos
<ul>
<li>Asegura que ciertas operaciones erróneas no ocurran</li>
<li>aunque no puede prevenir todas</li>

</ul></li>
<li>polimorfismo surge cuando el compilador encuentra que no necesita saber ciertas cosas</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgf742384">
<div class="slide-header"></div>
<h4 id="orgf742384">Tipos de Datos</h4>
<ul>
<li><b>Fuertemente Tipado</b> se ha vuelto un término popular
<ul>
<li>como <i>programación estructurada</i></li>
<li>informalmente, significa que el lenguaje previene al programador
de aplicar operaciones a los datos que no son apropiados</li>

</ul></li>
<li><b>Tipado Estático</b> significa que el compilador puede realizar todos
los chequeos en tiempo de compilación.</li>
<li>Ejemplos
<ul>
<li>Common Lisp is fuertemente tipado pero no <b>tipado estaticamente</b></li>
<li>Ada es estáticamente tipado</li>
<li>Pascal es casi estáticamente tipado</li>
<li>Java es fuertemente tipado, con una mezcla no trivial de cosas que
pueden ser chequeadas estaticamente y cosas que tienen que ser
chequeadas dinámicamente.</li>

</ul></li>

</ul>


<div class="slide-footer"></div>
</section>
<section id="slide-org3c6f48d">
<div class="slide-header"></div>
<h4 id="org3c6f48d">Tipos de Datos</h4>
<ul>
<li>Simples
<ul>
<li>Primitivos: integer, float, char, enum</li>
<li>Definidos por el Usuario</li>

</ul></li>
<li>Compuestos
<ul>
<li>Arreglos
<ul>
<li>strings</li>

</ul></li>
<li>Arreglos asociativos</li>
<li>Registros</li>
<li>Union</li>
<li>conjuntos</li>
<li>listas</li>
<li>punteros</li>
<li>archivos</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgc46007d">
<div class="slide-header"></div>
<h4 id="orgc46007d">Sistema de Tipos</h4>
<ul>
<li>Un <b>Sistema de Tipos</b> tiene reglas para
<ul>
<li>equivalencia de tipos (¿cuándo los tipos de dos valores son el mismo?)</li>
<li>compatibilidad de tipos (¿cuándo puede el valor de un tipo A ser
usado en un contexto donde se espera el tipo B?)</li>
<li>inferencia de tipos (¿Cuál es el tipo de una expresión, dado el
tipo de los operandos?)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org4d44fb3">
<div class="slide-header"></div>
<h4 id="org4d44fb3">Chequeo de Tipos</h4>
<ul>
<li>Dos Aproximaciones: <i>equivalencia estructural</i> y <i>equivalencia por nombre</i>
<ul>
<li>La equivalencia por nombre esta basado en las declaraciones</li>
<li>La equivalencia estructural esta basada en la noción de
significado detrás de esas declaraciones</li>
<li>Equivalencia por nombre es mas preferida hoy en dia.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orga538d22">
<div class="slide-header"></div>
<h4 id="orga538d22">Estructural vs. por Nombre</h4>
<ul>
<li>a veces es preferible estructural</li>

</ul>
<div class="org-src-container">

<pre  class="src src-pascal"><span style="color: #98fb98;">TYPE</span> stack_element = <span style="color: #98fb98;">INTEGER</span>; <span style="color: #ff4500;">(* </span><span style="color: #ff4500;">or whatever type the user prefers *)</span> 
MODULE stack; 
IMPORT stack_element; 
EXPORT push, pop; 
...
<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #87cefa;">push</span>(elem : stack_element); 
...
<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #87cefa;">pop</span>() : stack_element; 
...
</pre>
</div>
<ul>
<li>otras veces por nombre</li>

</ul>
<div class="org-src-container">

<pre  class="src src-pascal"><span style="color: #98fb98;">TYPE</span> celsius_temp = <span style="color: #98fb98;">REAL</span>; 
fahrenheit_temp = <span style="color: #98fb98;">REAL</span>; 
<span style="color: #98fb98;">VAR</span> c : celsius_temp; 
    f : fahrenheit_temp; 

<span style="color: #00ffff;">BEGIN</span> <span style="color: #ff4500;">(* </span><span style="color: #ff4500;">alias_types *)</span>
    c := 100.0;
    f := c;                 <span style="color: #ff4500;">(* </span><span style="color: #ff4500;">this should probably be an error *)</span>
</pre>
</div>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-org0a42195">
<div class="slide-header"></div>
<h3 id="org0a42195">Chequeo de Tipos: Coerción</h3>
<div class="outline-text-3" id="text-org0a42195">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgedfb21d">
<div class="slide-header"></div>
<h4 id="orgedfb21d">Chequeo de Tipos: Coerción</h4>
<ul>
<li>Coerción
<ul>
<li>Cuando una expresión es usada en un contexto donde un tipo
diferente se espera, uno normalmente obtiene un error.</li>
<li>Pero, y en esta situación?:</li>

</ul></li>

</ul>
<div class="org-src-container">

<pre  class="src src-pascal"><span style="color: #98fb98;">var</span> a : <span style="color: #98fb98;">integer</span>; b, c : <span style="color: #98fb98;">real</span>;
...

c := a + b;
</pre>
</div>
<ul>
<li>Muchos Lenguajes lo permiten.</li>
<li>Puede ser basado solo en los tipos de los operandos (Fortran)</li>

</ul>
<div class="slide-footer"></div>
</section>
<section id="slide-org35a1552">
<div class="slide-header"></div>
<h4 id="org35a1552">Chequeo de Tipos: Coerción</h4>
<ul>
<li>Coerción
<ul>
<li><b>C</b> usa mucha coerción, pero con reglas simples:
<ul>
<li>todos los <code>float</code>  en expresiones se vuelven <code>double</code></li>
<li><code>short</code> <code>int</code> y <code>char</code> se vuelven <code>int</code> en las expresiones</li>
<li>Si es necesario, la precisión es removida cuando se asigna a
lado izquierdo de la asignación.</li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org25427ae">
<div class="slide-header"></div>
<h4 id="org25427ae">Chequeo de Tipos: Coerción</h4>
<ul>
<li>De hecho, las reglas de coerción son una relajación del chequeo de tipos
<ul>
<li>Nuevas opiniones lo consideran una mala idea</li>
<li>Lenguajes como Modula-2 y Ada no permiten coerción</li>
<li>C++, sin embargo lo usa en extremo</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org3156d7d">
<div class="slide-header"></div>
<h4 id="org3156d7d">Chequeo de Tipos: Coerción</h4>
<ul>
<li>Es importante entender la diferencia entre:
<ul>
<li><b>Conversión de Tipos</b> que es <i>explícito</i> y</li>
<li><b>Coerción de Tipos</b> que es <i>implícito</i></li>
<li>para las conversiones a veces se usa la palabra <i>cast</i> (por C)</li>

</ul></li>

</ul>


<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgc32bea0">
<div class="slide-header"></div>
<h3 id="orgc32bea0">Arreglos</h3>
<ul>
<li>Los Arreglos son el tipo compuesto mas importante en los lenguajes
de alto nivel. Es una agrupación de elementos (usualmente) homogeneos
 en la cual los elementos individuales son son
identificados por su posición en la agrupación relativo a su primer
elemento.</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgfcb07ba">
<div class="slide-header"></div>
<h4 id="orgfcb07ba">Cuestiones de Diseño de Arreglos</h4>
<ul>
<li>¿Cuales tipos son legales para ser subíndices?</li>
<li>¿Es chequeado que el subíndice cumpla el rango definido?</li>
<li>¿Cuándo se liga el rango de subíndices?</li>
<li>¿Cuándo tiene lugar el alojamiento de espacio?</li>
<li>¿Cual es el número máximo de subíndices?</li>
<li>¿Pueden los arreglos ser inicializados?</li>
<li>¿Se pueden definir porciones (slices) de arreglos?</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org14ae91b">
<div class="slide-header"></div>
<h4 id="org14ae91b">Accediendo a los elementos del Arreglo</h4>
<ul>
<li>Es una función desde subíndices a elementos 
<code>array_name(index_value_list)</code> \(\to\) <code>an element</code></li>
<li>Sintaxis
<ul>
<li>FORTRAN, PL/I, Ada usan <i>paréntesis</i>
<ul>
<li>Ada explícitamente usa paréntesis para mostrar uniformidad entre
referencia de arreglos y llamadas a función porque ambas mapean resultados</li>

</ul></li>
<li>La mayoría de los otros lenguajes usan <i>corchetes</i></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orge1ff148">
<div class="slide-header"></div>
<h4 id="orge1ff148">Tipos de los subíndices de los arreglos</h4>
<ul>
<li>FORTRAN, C: solo enteros (integer)</li>
<li>PASCAL: cualquier tipo ordinal (integer, boolean, char, enumeration)</li>
<li>Ada: Enteros y enumeración (incluídos char y booleanos)</li>
<li>Java: solo tipos enteros</li>
<li>C, C++, Perl, y Fortran no especifican chequeo de rango</li>
<li>Java, ML, C#, especifican chequeo de rango</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orga66a428">
<div class="slide-header"></div>
<h4 id="orga66a428">Categoría de Arreglos</h4>
<ul>
<li class="fragment roll-in">Estático: rango de subíndices son ligados estáticamente y el
alojamiento de memoria es estático (antes del tiempo de ejecución)
<ul>
<li>ventaja: eficiencia (no hay alojamiento dinámico)</li>

</ul></li>
<li class="fragment roll-in">(stack)dinámico Fijo: los subíndices son ligados estáticamente, pero
el alojamiento es hecho en tiempo de declaración
<ul>
<li>ventaja: eficiencia de espacio</li>

</ul></li>
<li class="fragment roll-in">(stack)dinámico: rangos de subíndices son ligados dinámicamente y el
almacenamiento es dinámico (hecho en tiempo de ejecución)</li>
<li class="fragment roll-in">(heap)dinámico Fijo: el almacenamiento es ligado dinámicamente pero
fijo después del alojamiento.</li>
<li class="fragment roll-in">(heap)dinámico: la ligadura de los subíndices y el almacenamiento es
dinámico y puede cambiar
<ul>
<li>ventaja: flexibilidad (los arreglos pueden crecer o disminuir
durante la ejecución del programa)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org06831d1">
<div class="slide-header"></div>
<h4 id="org06831d1">Categoría de Arreglos</h4>
<ul>
<li>Los arreglos de <b>C</b> y <b>C++</b> que incluyen el modificador <code>static</code> son <i>Estáticos</i></li>
<li>Los arreglos de <b>C</b> y <b>C++</b> sin el modificador <code>static</code> son <i>(stack)dinámicos Fijos</i></li>
<li>Los arreglos de <b>Ada</b> pueden ser <i>(stack)dinámicos</i></li>
<li><b>C</b> y <b>C++</b> proveen arreglos <i>(heap)dinámicos Fijos</i> (<b>C#</b> con sus
<code>ArrayList</code> )</li>
<li><b>Perl</b> y <b>JavaScript</b> soporta arreglos <i>(heap)dinámicos</i>.</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orga525d9e">
<div class="slide-header"></div>
<h4 id="orga525d9e">(Stack) Dinámicos fijos</h4>

<figure>
<img src="adaarreglo.png" alt="adaarreglo.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orga90e953">
<div class="slide-header"></div>
<h4 id="orga90e953">Arreglos</h4>
<ul>
<li>Elementos Contiguos
<ul>
<li>Dirigido por Columnas - solo en <b>Fortrand</b></li>
<li>Dirigido por filas
<ul>
<li>usada por el resto de lenguajes</li>
<li>hace que el <code>array [a..b,c..d]</code> sea igual a <code>array [a..b] of array [c..d]</code></li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgcddd8bb">
<div class="slide-header"></div>
<h4 id="orgcddd8bb">Arreglos</h4>

<figure>
<img src="rowcolumnmajor.png" alt="rowcolumnmajor.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-org5c20fca">
<div class="slide-header"></div>
<h4 id="org5c20fca">Arreglos</h4>
<ul>
<li><b>Dos estrategias para arreglos</b>
<ul>
<li>Elementos continuos</li>
<li>punteros de filas</li>

</ul></li>
<li><b>Punteros de Filas</b>
<ul>
<li>una opcion en <b>C</b></li>
<li>permite a las filas colocarse en cualquier parte de la memoria</li>
<li>bueno para matrices cuando las filas son de diferente longitud
<ul>
<li>ejemplo arreglo de strings</li>

</ul></li>
<li>requiere espacio para los punteros</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org6536819">
<div class="slide-header"></div>
<h4 id="org6536819">Arreglos</h4>

<figure>
<img src="arraypontrowc.png" alt="arraypontrowc.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orga833303">
<div class="slide-header"></div>
<h4 id="orga833303">Inicialización de Arreglos</h4>
<ul>
<li>Algunos Lenguajes permiten inicialización en el tiempo de
alojamiento.
<ul>
<li>ejemplo de <b>C</b>, <b>C++</b>, <b>Java</b>, <b>C#</b>
<ul>
<li><code>int list [] = {4, 5, 7, 83}</code></li>

</ul></li>
<li>cadena de caracteres en <b>C</b> y <b>C++</b>
<ul>
<li><code>char name [] = "freddie";</code></li>

</ul></li>
<li>Array of strings en <b>C</b> and <b>C++</b>
<ul>
<li><code>char *names [] = {"bob", "jake", "Joe"};</code></li>

</ul></li>
<li><b>Java</b> 
<ul>
<li><code>String[] names = {"Bob", "Jake", "Joe"};</code></li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgb8b15d9">
<div class="slide-header"></div>
<h4 id="orgb8b15d9">Operaciones de Arreglos</h4>
<ul>
<li><b>APL</b> provee el mas poderoso conjunto de operadores para procesar
vectores y matrices y operaciones unarias (por ejemplo revertir
elementos de una columna)</li>
<li><b>Ada</b> permite asignación de arreglos y concatenación</li>
<li><b>Fortran</b> provee operaciones <i>elementales</i> a causa de que son entre
pares de elementos del arreglo
<ul>
<li>Por ejemplo, el operador + entre dos arreglos resulta en un
arreglo con la suma de los pares de elementos de los dos arreglos.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org157c998">
<div class="slide-header"></div>
<h4 id="org157c998">Arreglos</h4>
<ul>
<li>Ejemplo <code>A : array [L1..U1] of array [L2::U2] of array [L3..U3] of elem;</code>
<ul>
<li>\(D1 = U1 - L1 + 1\)</li>
<li>\(D2 = U2 - L2 + 1\)</li>
<li>\(D3 = U3 - L3 + 1\)</li>
<li>\(S3 = \) tamaño de <code>elem</code></li>
<li>\(S2 = D3 * S3\)</li>
<li>\(S1 = D2 * S2\)</li>

</ul></li>

</ul>

<p>
\( A(i,j,k) = \) <code>address of A</code> \( + (i * S1) + (j * S2) + (k * S3)  -
[(L1 * S1) + (L2 * S2) + (L3 * S3)] \)
</p>


<div class="slide-footer"></div>
</section>
<section id="slide-org1d3708e">
<div class="slide-header"></div>
<h4 id="org1d3708e">Slices</h4>
<ul>
<li>Una <i>porción</i> (slice) de un arreglo es una subestructura de un
arreglo; un mecanismo de referenciación.</li>
<li>Los <i>Slices</i> son útilies en lenguages que tienen operaciones sobre
arreglos (APL, FORTRAN etc).</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgb1568d9">
<div class="slide-header"></div>
<h4 id="orgb1568d9">Slices</h4>

<figure>
<img src="slicesfort.png" alt="slicesfort.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-org8f2747c">
<div class="slide-header"></div>
<h4 id="org8f2747c">Descriptores en Tiempo de Compilación</h4>

<figure>
<img src="descriptoresarray.png" alt="descriptoresarray.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-org3da4c28">
<div class="slide-header"></div>
<h4 id="org3da4c28">Arreglos Asociativos</h4>
<ul>
<li>Un <i>arreglo asociativo</i> es una colección no ordenada de elementos de
datos que son indexados por un numero igual de valores llamados
<i>claves</i> (keys)
<ul>
<li>claves definidas por el usuario deben ser almacenadas</li>

</ul></li>
<li>Ahora llamados <i>Diccionarios</i></li>
<li>en <b>PERL</b>
<ul>
<li>Nombres comenzando con <code>%</code>; literales son delimitados con
paréntesis
<ul>
<li><code>%hi_temps</code> = ("Mon" =&gt; 77, "Tue" =&gt; 79, "Wed" =&gt; 65, &#x2026; ),</li>

</ul></li>
<li>Para acceder se usan llaves y claves:
<ul>
<li><code>%hi_temps{"wed"} = 83;</code></li>

</ul></li>
<li>Los elementos pueden ser removidos con <code>delete</code>
<ul>
<li><code>delete %hi_temps{"Tue"}</code></li>

</ul></li>

</ul></li>

</ul>


<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-org1c1d8f1">
<div class="slide-header"></div>
<h3 id="org1c1d8f1">Strings</h3>
<ul>
<li><i>Strings</i> son en realidad arreglos de caracteres</li>
<li>Son frecuentemente casos especiales, para darles flexibilidad (como
polimorfismo y tamaño dinámico) que no es disponible para arreglos
en general
<ul>
<li>Es mas facil proveer estas cosas para <i>strings</i> que para arreglos
en general porque los <i>strings</i> son de una dimensión y no circulares.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgb7cac06">
<div class="slide-header"></div>
<h3 id="orgb7cac06">Tipo Registros</h3>
<ul>
<li>Un registro es un conjunto posiblemente heterogeneo de elementos de
datos en el cual los elementos individuales son identificados por su nombre</li>
<li>Cuestiones de Diseño
<ul>
<li>¿Cual es la sintaxis para referenciar los campos?</li>
<li>¿Son permitidas las referencias elípticas?</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgec6f2e4">
<div class="slide-header"></div>
<h4 id="orgec6f2e4">Tipo Registros</h4>
<ul>
<li>Cobol</li>

</ul>
<div class="org-src-container">

<pre  class="src src-cobol">01 EMPLOYEE-RECORD.
   02 EMPLOYEE-NAME.
      05 FIRST    PICTURE IS x(20).
      05 MIDDLE   PICTURE IS x(10).
      05 LAST     PICTURE IS x(20).
   02 HOURLY-RATE PICTURE IS 99v99.
</pre>
</div>
<ul>
<li>Ada</li>

</ul>
<div class="org-src-container">

<pre  class="src src-ada"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Employee_Name_Type</span> <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">record</span>
   First : String (<span style="color: #7fffd4;">1..20</span>);
   Middle : String (<span style="color: #7fffd4;">1..10</span>);
   Last : String (<span style="color: #7fffd4;">1..20</span>);
<span style="color: #00ffff;">end</span> <span style="color: #00ffff;">record</span>;
<span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Employee_Record_Type</span> <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">record</span>
   Employee_Name: Employee_Name_Type;
   Hourly_Rate: Float;
<span style="color: #00ffff;">end</span> <span style="color: #00ffff;">record</span>;
Employee_Record: Employee_Record_Type;
</pre>
</div>

<div class="slide-footer"></div>
</section>
<section id="slide-org18497b6">
<div class="slide-header"></div>
<h4 id="org18497b6">Registros</h4>
<ul>
<li>Referencia a los campos
<ul>
<li><b>COBOL</b> <code>field_name OF record_name_1 OF ... OF record_name_n</code></li>
<li>Otros (notación con punto) <code>record_name_1.record_name_2. ... record_name_n.field_name</code></li>

</ul></li>
<li>Referencias completamente calificadas: debe incluir todo el camino
de nombres de registros.</li>
<li>Referencia elíptica: permite no especificar nombres intermedios
siempre que la referencia sea no ambigua. Ej: <code>FIRST OF EMP-REC</code> en <b>COBOL</b></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgc941de7">
<div class="slide-header"></div>
<h4 id="orgc941de7">Operaciónes de Registros</h4>
<ul>
<li>La asignación es muy común si los tipos son identicos</li>
<li><b>Ada</b> permite comparación de registros</li>
<li>Los registros de <b>Ada</b> pueden ser inicializados con conjunto de literales</li>
<li><b>COBOL</b> provee <code>MOVE CORRESPONDING</code>
<ul>
<li>copia un campo de un registro origen al correspondiente campo en
el registro destino.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orga0b5b32">
<div class="slide-header"></div>
<h4 id="orga0b5b32">Comparación con Arreglos</h4>
<ul>
<li>Tiene un diseño directo y seguro</li>
<li>Son usados cuando el agrupamiento de datos es heterogeneo</li>
<li>El acceso es mucho mas rápido que en arreglos porque el acceso a los
nombres de los campos es estático</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgbce0a94">
<div class="slide-header"></div>
<h4 id="orgbce0a94">Implementación de Registros</h4>

<figure>
<img src="implementregistros.png" alt="implementregistros.png">

</figure>

<p>
Un desplazamiento de dirección relativo al comienzo del registro es
asociado con cada campo.
</p>

<div class="slide-footer"></div>
</section>
<section id="slide-org0aba25f">
<div class="slide-header"></div>
<h4 id="org0aba25f">Tipo Uniones</h4>
<ul>
<li>Una <i>Union</i> es un tipo a cuyas variables se les permite
almacenar diferentes valores de tipo (estructura) en diferentes tiempos durantes
la ejecución.</li>
<li>Cuestiones de Diseño
<ul>
<li>¿Debería requerirse chequeo de tipos?</li>
<li>¿Deberían incluirse como tipos particulares de Registros?</li>

</ul></li>
<li><b>Fortran</b>, <b>C</b>, y <b>C++</b> provee constructores de <i>Union</i> sin soporte
para chequeo de tipos se llaman <i>uniones libres</i></li>
<li>Chequeo de tipos en <i>Uniones</i> requieren que se incluya un indicador
de tipo llamado <i>discriminante</i>
<ul>
<li>soportado por <b>Ada</b></li>

</ul></li>

</ul>


<div class="slide-footer"></div>
</section>
<section id="slide-orgf200abe">
<div class="slide-header"></div>
<h4 id="orgf200abe">tipo Union de Ada</h4>
<div class="org-src-container">

<pre  class="src src-ada"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Shape</span> <span style="color: #00ffff;">is</span> (Circle, Triangle, Rectangle);
<span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Colors</span> <span style="color: #00ffff;">is</span> (Red, Green, Blue);
<span style="color: #00ffff;">type</span> <span style="color: #87cefa;">Figure</span> (Form: Shape) <span style="color: #00ffff;">is</span> <span style="color: #00ffff;">record</span>
  Filled: Boolean;
  Color: Colors;
  <span style="color: #00ffff;">case</span> Form <span style="color: #00ffff;">is</span> 
      <span style="color: #00ffff;">When</span> Circle =&gt; Diameter : Float;
      <span style="color: #00ffff;">When</span> Triangle =&gt; 
             LeftSide, Rightside: Integer;
             Angle: Float;
      <span style="color: #00ffff;">when</span> Rectangle =&gt; Side1,Side2: Integer;
  <span style="color: #00ffff;">end</span> <span style="color: #00ffff;">case</span>;
<span style="color: #00ffff;">end</span> <span style="color: #00ffff;">record</span>;
</pre>
</div>

<figure>
<img src="adaunion.png" alt="adaunion.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-org65784a9">
<div class="slide-header"></div>
<h4 id="org65784a9">Evaluación de Uniones</h4>
<ul>
<li>también llamados registros variantes</li>
<li>Es una construcción potencialmente insegura
<ul>
<li>no permite chequeo de tipos o es muy caro</li>

</ul></li>
<li><b>Java</b> y <b>C#</b> no soportan uniones
<ul>
<li>Como reflejo de la creciente preocupación por la seguridad en los lenguajes de programación</li>

</ul></li>
<li>La falta de discriminante (tag) significa que uno no sabe lo que hay almacenado</li>
<li>La posibilidad de cambiar el discriminante permite acceder a campos erroneamente</li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-org7b392d8">
<div class="slide-header"></div>
<h3 id="org7b392d8">Punteros y Tipos Recursivos</h3>
<div class="outline-text-3" id="text-org7b392d8">
</div><div class="slide-footer"></div>
</section>
<section id="slide-org9847e2a">
<div class="slide-header"></div>
<h4 id="org9847e2a">Tipo Punteros</h4>
<ul>
<li>Los Punteros sirven para dos propósitos:
<ul>
<li>acceso eficiente (y a veces intuitivo) a objetos muy elaborados
(como en <b>C</b>)</li>
<li>creación dinámica de estructuras ligadas, en conjunción con
administración de memoria <i>heap</i></li>

</ul></li>
<li>Varios lenguajes (e.g. <b>Pascal</b> ) restringen los punteros para
acceder a cosas en el <i>heap</i></li>
<li>Los punteros son usados en un modo <i>por valor</i> de las variables
<ul>
<li>No se necesitan como modo <i>por referencia</i></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org7b48372">
<div class="slide-header"></div>
<h4 id="org7b48372">Punteros y Tipos Recursivos</h4>

<figure>
<img src="lisppunt.png" alt="lisppunt.png">

</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgd8bc50a">
<div class="slide-header"></div>
<h4 id="orgd8bc50a">Punteros y Tipos Recursivos</h4>
<ul>
<li><b>C</b> punteros y arreglos
<ul>
<li><code>int *a == int a[]</code></li>
<li>~int **a == int *a[]</li>

</ul></li>
<li>Las equivalencias no siempre ocurren
<ul>
<li>Especificamente, una declaración aloja un arreglo si se especifica
un tamaño para la primera dimensión</li>
<li>en caso contrario aloja un puntero
<ul>
<li><code>int **a, int *a[]</code> puntero a puntero a int</li>
<li><code>int *a[n]</code>,  arreglo de <i>n</i> elementos de punteros</li>
<li><code>int a[n][m]</code> arreglo de dos dimensiones</li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-org49179a2">
<div class="slide-header"></div>
<h4 id="org49179a2">Punteros y Tipos Recursivos</h4>
<ul>
<li>El compilador tiene que ser capaz de establecer el tamaño de las
cosas apuntadas por los punteros
<ul>
<li>Por lo tanto las siguientes no son válidas:
<ul>
<li><code>int a[][]</code> mal</li>
<li><code>int (*a)[]</code> mal</li>

</ul></li>
<li>regla de declaración de <b>C</b>: lee a la derecha tanto como puede
(sujeto a paréntesis), luego a la izquierda, y luego sube de nivel
y repite.
<ul>
<li><code>int *a[n]</code> arreglo de <i>n</i> elementos de punteros a enteros</li>
<li><code>int (*a)[n]</code> puntero a un arreglo de <i>n</i> elementos de enteros</li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgcba6f5a">
<div class="slide-header"></div>
<h4 id="orgcba6f5a">Punteros y Tipos Recursivos</h4>
<ul>
<li>Los problemas con punteros <i>cogados</i> se deben a:
<ul>
<li>desalojo explícito de objetos del <i>heap</i>
<ul>
<li>solo en lenguajes que tienen explícito desalojo</li>

</ul></li>
<li>desalojo implícito de objetos elaborados</li>

</ul></li>
<li>Dos mecanismos de implementación para atrapar punteros <i>colgados</i>
<ul>
<li><i>Tombstones</i> lapidas</li>
<li><i>Locks and Keys</i> llaves y cerraduras</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgbc38414">
<div class="slide-header"></div>
<h3 id="orgbc38414">Listas</h3>
<ul>
<li>Una <i>Lista</i> es definida recursivamente ya sea como una lista vacía o
un par consistente de un objeto (que puede ser una lista o un átomo)
y otra lista (mas corta)
<ul>
<li>Las <i>Listas</i> son ideales para programar en lenguajes lógicos y funcionales
<ul>
<li>En <b>Lisp</b> de hecho un programa <i>es</i> una lista, y puede
extenderse a si mismo para construir una lista y ejecutarla</li>

</ul></li>
<li>Las <i>Listas</i> pueden usarse en programas imperativos.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orge2984b9">
<div class="slide-header"></div>
<h3 id="orge2984b9">Archivos y Entrada/Salida</h3>
<ul>
<li>Entrada/Salida (E/S) facilita al programa a comunicarse con el mundo externo
<ul>
<li>E/S interactiva y E/S con archivos</li>

</ul></li>
<li>Interactivo generalmente implica comunicación con usuarios humanos y
dispositivos físicos</li>
<li>Archivos generalmente se refieren a almacenamiento fuera de linea
implementado por el sistema operativo.</li>
<li>Archivos pueden ser categorizados en:
<ul>
<li>Temporarios</li>
<li>Persistentes</li>

</ul></li>

</ul>
<div class="slide-footer"></div>
</section>
</section>
</div>
</div>
<script src="../reveal.js-master/lib/js/head.min.js"></script>
<script src="../reveal.js-master/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 't',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'cube', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js-master/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js-master/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js-master/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js-master/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js-master/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
,});
</script>
</body>
</html>
