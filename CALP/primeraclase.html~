<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conceptos Avanzados en Lenguajes de Programación</title>
<meta name="author" content="(Claudio Vaucheret / Marcelo Amaolo)"/>
<link rel="stylesheet" href="../reveal.js-master/css/reveal.css"/>
<link rel="stylesheet" href="../reveal.js-master/css/theme/solarized.css" id="theme"/>
<link rel="stylesheet" href=""/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js-master/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="" data-background-size="" data-background-repeat="" data-background-transition="">
<h1>Conceptos Avanzados en Lenguajes de Programación</h1><h2>Claudio Vaucheret / Marcelo Amaolo</h2><h2><a href="mailto:cv@fi.uncoma.edu.ar / marcelo.amaolo@fi.uncoma.edu.ar">cv@fi.uncoma.edu.ar / marcelo.amaolo@fi.uncoma.edu.ar</a></h2><h2><span class="timestamp-wrapper"><span class="timestamp">&lt;2016-08-16 mar&gt;</span></span></h2>
</section>
<section id="table-of-contents">
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#/slide-orgheadline29">Introducción</a>
<ul>
<li><a href="#/slide-orgheadline1">Razones para estudiar Conceptos de Lenguajes de Programación</a></li>
<li><a href="#/slide-orgheadline2">Dominios de Programación</a></li>
<li><a href="#/slide-orgheadline8">Criterios de Evaluación de Lenguajes</a>
<ul>
<li><a href="#/slide-orgheadline3">Legibilidad</a></li>
<li><a href="#/slide-orgheadline4">Escribilidad</a></li>
<li><a href="#/slide-orgheadline5">Confiabilidad</a></li>
<li><a href="#/slide-orgheadline6">Costo</a></li>
<li><a href="#/slide-orgheadline7">Otros</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline14">Influencias en el diseño de los lenguajes</a>
<ul>
<li><a href="#/slide-orgheadline9">Influencia de la Arquitectura de Computadoras</a></li>
<li><a href="#/slide-orgheadline10">Arquitectura de Von Neumann</a></li>
<li><a href="#/slide-orgheadline11">Influencia de las Metodogías de Programación</a></li>
<li><a href="#/slide-orgheadline12">Categoría de Lenguajes</a></li>
<li><a href="#/slide-orgheadline13">Compromisos en el diseño de Lenguajes</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline28">Métodos de Implementación</a>
<ul>
<li><a href="#/slide-orgheadline15">Capas de Implementación de Lenguajes</a></li>
<li><a href="#/slide-orgheadline16">Compilación</a></li>
<li><a href="#/slide-orgheadline17">El proceso de compilación</a></li>
<li><a href="#/slide-orgheadline18">Terminología Adicional de Compilación</a></li>
<li><a href="#/slide-orgheadline19">Ejecución del Código Máquina</a></li>
<li><a href="#/slide-orgheadline20"><i>Cuello de botella</i> de Von Neumann</a></li>
<li><a href="#/slide-orgheadline21">Interpretación Pura</a></li>
<li><a href="#/slide-orgheadline22">Proceso de Interpretación Pura</a></li>
<li><a href="#/slide-orgheadline23">Sistemas de Implementación Híbrida</a></li>
<li><a href="#/slide-orgheadline24">Proceso de Implementación Híbrida</a></li>
<li><a href="#/slide-orgheadline25">Sistemas de Implementación <i>Just in Time</i></a></li>
<li><a href="#/slide-orgheadline26">Preprocesadores</a></li>
<li><a href="#/slide-orgheadline27">Entornos de Programación</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#/slide-orgheadline65">Evolución de los Lenguajes de Programación</a>
<ul>
<li><a href="#/slide-orgheadline30">Lenguajes de Programación</a></li>
<li><a href="#/slide-orgheadline31">Evolución de los primeros lenguajes</a></li>
<li><a href="#/slide-orgheadline33">Konrad Zuze's language de la computadora Z4.</a>
<ul>
<li><a href="#/slide-orgheadline32">Zuse's Plankalkül</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline38">Codigo Máquina: pseudocodigos ¿?</a>
<ul>
<li><a href="#/slide-orgheadline34">Escribir en lenguaje máquina</a></li>
<li><a href="#/slide-orgheadline35">Shorte Code Mauchly (1949)</a></li>
<li><a href="#/slide-orgheadline36">Speedcoding</a></li>
<li><a href="#/slide-orgheadline37">Otros sistemas relacionados</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline48">IBM 704 y Fortran</a>
<ul>
<li><a href="#/slide-orgheadline39">Fortan</a></li>
<li><a href="#/slide-orgheadline40">Proceso de Diseño</a></li>
<li><a href="#/slide-orgheadline41">Fortran I</a></li>
<li><a href="#/slide-orgheadline42">Fortran I</a></li>
<li><a href="#/slide-orgheadline43">Fortran II</a></li>
<li><a href="#/slide-orgheadline44">Fortran IV</a></li>
<li><a href="#/slide-orgheadline45">Fortran 77</a></li>
<li><a href="#/slide-orgheadline46">Fortran 90</a></li>
<li><a href="#/slide-orgheadline47">Evaluación de Fortran</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline54">Programación Funcional: LISP</a>
<ul>
<li><a href="#/slide-orgheadline49">LISP</a></li>
<li><a href="#/slide-orgheadline50">Representación de Listas LISP</a></li>
<li><a href="#/slide-orgheadline51">Evaluación de LISP</a></li>
<li><a href="#/slide-orgheadline52">Scheme</a></li>
<li><a href="#/slide-orgheadline53">COMMON LISP</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline62">Primera sofisticación: ALGOL 60</a>
<ul>
<li><a href="#/slide-orgheadline55">Algol 60</a></li>
<li><a href="#/slide-orgheadline56">Primitivo proceso de diseño</a></li>
<li><a href="#/slide-orgheadline57">ALGOL 58</a></li>
<li><a href="#/slide-orgheadline58">Implementación de ALGOL 58</a></li>
<li><a href="#/slide-orgheadline59">ALGOL 60</a></li>
<li><a href="#/slide-orgheadline60">Evaluación de ALGOL 60</a></li>
<li><a href="#/slide-orgheadline61">Evaluación de ALGOL 60</a></li>
</ul>
</li>
<li><a href="#/slide-orgheadline63">Aplicaciones Comerciales: COBOL</a></li>
<li><a href="#/slide-orgheadline64">Comienzo de tiempo compartido: BASIC</a></li>
</ul>
</li>
</ul>
</div>
</nav>
</section>

<section>
<section id="slide-orgheadline29">
<div class="slide-header"></div>
<h2 id="orgheadline29">Introducción</h2>
<div class="outline-text-2" id="text-orgheadline29">
</div><div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline1">
<div class="slide-header"></div>
<h3 id="orgheadline1">Razones para estudiar Conceptos de Lenguajes de Programación</h3>
<ul>
<li>Incrementa la habilidad para expresar ideas</li>
<li>Mejora la capacidad de elegir el lenguaje apropiado</li>
<li>Incrementa la capacidad de aprender nuevos lenguajes</li>
<li>Mejora el entendimiento del funcionamiento interno del lenguaje
(implementación)</li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline2">
<div class="slide-header"></div>
<h3 id="orgheadline2">Dominios de Programación</h3>
<ul>
<li>Aplicaciones Científicas
<ul>
<li>Gran número de computación de punto flotante</li>
<li>Fortran</li>

</ul></li>
<li>Aplicaciones Empresariales
<ul>
<li>Producción de Reportes, uso de números decimales y caracteres</li>
<li>Cobol</li>

</ul></li>
<li>Inteligencia Artificial
<ul>
<li>Manipulación simbólica (en lugar de números)</li>
<li>LISP</li>

</ul></li>
<li>Sistemas de Programación
<ul>
<li>Necesidad de eficiencia (debido al uso continuo)</li>
<li>C</li>

</ul></li>
<li>Software para la WEB
<ul>
<li>Colección ecléctica de lenguajes: maukup (e.g. HTML5), scripting
(e.g. PHP), de propósito general (e.g. Java)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline8">
<div class="slide-header"></div>
<h3 id="orgheadline8">Criterios de Evaluación de Lenguajes</h3>
<ul>
<li><b>Legibilidad</b>: la facilidad con la cual los programas pueden ser
leídos y entendidos.</li>
<li><b>Escribilidad</b>: la facilidad con la cual un lenguaje puede ser usado
para crear programas</li>
<li><b>Confiabilidad</b>: El grado en que el lenguaje funciona de acuerdo a
sus especificaciones.</li>
<li><b>Costo</b>: de uso, compilación, mantenimiento etc.</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline3">
<div class="slide-header"></div>
<h4 id="orgheadline3">Legibilidad</h4>
<ul>
<li>Simplicidad
<ul>
<li>Un conjunto manejable de características y construcciones</li>
<li>Poca multiplicidad de características (medios de realizar la misma operación)</li>
<li>Minima sobrecarga de operadores</li>

</ul></li>
<li>Ortogonalidad
<ul>
<li>Un conjunto relativamente pequeño de construcciones primitivas que
puedan ser combinadas en un numero pequeño de modos</li>
<li>Toda posible combinación sea legal.</li>

</ul></li>
<li>Sentencas de Control
<ul>
<li>La presencia de bien conocidas estructuras de control</li>

</ul></li>
<li>Tipos de Datos y Estructuras
<ul>
<li>La presencia de facilidades adecuadas para definir estructuras de datos</li>

</ul></li>
<li>Consideraciones sintácticas
<ul>
<li>Composición flexible de identificadores</li>
<li>Palabras especiales y métodos para formar sentencias compuestas</li>
<li>Construcciones autodescriptivas, palabras reservadas
significativas</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline4">
<div class="slide-header"></div>
<h4 id="orgheadline4">Escribilidad</h4>
<ul>
<li>Simplicidad y ortogonalidad
<ul>
<li>Pocas constucciones, numero pequeño de primitivas y pocas reglas
para combinarlas.</li>

</ul></li>
<li>Soporte para la abstracción
<ul>
<li>La habilidad para definir y usar estructuras complejas o
operaciones de modo que los detalles puedan ser ignorados</li>

</ul></li>
<li>Expresibilidad
<ul>
<li>Un conjunto conveniente de modos de especificar operaciones</li>
<li>Ejemplo: La inclusión de la sentencia <b>FOR</b> en  muchos lenguajes modernos</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline5">
<div class="slide-header"></div>
<h4 id="orgheadline5">Confiabilidad</h4>
<ul>
<li>Chequeo de Tipos
<ul>
<li>verificación de errores de tipos</li>

</ul></li>
<li>Manejo de Excepciones
<ul>
<li>interceptar errores en ejecución y tomar medidas correctivas</li>

</ul></li>
<li>Aliasing
<ul>
<li>Presencia de dos o mas distintas referencias para el mismo lugar
de memoria</li>

</ul></li>
<li>Legibilidad y Escribilidad
<ul>
<li>Un lenguage que no soporta modos "naturales" de expresar un
algoritmo necesariamente usará aproximaciones "no naturales" y asi
reducirá la confiabilidad</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline6">
<div class="slide-header"></div>
<h4 id="orgheadline6">Costo</h4>
<ul>
<li>Costo de &#x2026;
<ul>
<li>Entrenar programadores para usar un lenguaje</li>
<li>Escribir programas (cercano a aplicaciones particulares)</li>
<li>Compilar programas</li>
<li>Ejecutar programas</li>
<li>Implementar Lenguajes (disponibilidad de compiladores libres)</li>
<li>Confiabilidad: Confiabilidad pobre lleva a altos costos</li>
<li>Mantener programas</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline7">
<div class="slide-header"></div>
<h4 id="orgheadline7">Otros</h4>
<ul>
<li>Portabildad
<ul>
<li>La facilidad con que los programas puedan moverse de una
implementación a otra</li>

</ul></li>
<li>Generalidad
<ul>
<li>Su aplicabilidad a un amplio rango de aplicaciones.</li>

</ul></li>
<li>Bien definido
<ul>
<li>La completitud y precisión de la definición oficial del lenguaje</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline14">
<div class="slide-header"></div>
<h3 id="orgheadline14">Influencias en el diseño de los lenguajes</h3>
<ul>
<li>Arquitectura de Computadoras
<ul>
<li>Lenguajes son desarrollados alrededor de la arquitectura de
computadora prevaleciente, conocida como arquitectura de <i>von Neumann</i></li>

</ul></li>
<li>Metodologías de Programación
<ul>
<li>Nuevas metodologías de desarrollo de software (e.g. desarrollode
software orientado a objetos) llevan a nuevos paradigmas y por
extensión a nuevos lenguajes de programación</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline9">
<div class="slide-header"></div>
<h4 id="orgheadline9">Influencia de la Arquitectura de Computadoras</h4>
<ul>
<li>Arquitectura de Computadora bien conocida: Von Neumann</li>
<li>Lenguajes Imperativos mas dominantes debido a la arquitectura
dominante
<ul>
<li>Datos y Programas almacenados en memoria</li>
<li>Memoria Separada de la CPU</li>
<li>Instrucciones y Datos son conducidos desde la Memoria a la CPU</li>
<li>Bases para los lenguajes imperativos
<ul>
<li>Variables modelan celdas de memoria</li>
<li>La iteración es eficiente</li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline10">
<div class="slide-header"></div>
<h4 id="orgheadline10">Arquitectura de Von Neumann</h4>

<figure>
<p><img src="vonneumann.png" alt="vonneumann.png"> 
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline11">
<div class="slide-header"></div>
<h4 id="orgheadline11">Influencia de las Metodogías de Programación</h4>
<ul>
<li>Décadas de los 50 y 60: Simples aplicaciones; preocupación principal
la eficiencia</li>
<li>Finales de los 60: Eficiencia de programación toma importancia:
legibilidad, mejores estructuras de control
<ul>
<li>Programación Estructurada</li>
<li>Diseño <i>top-down</i> y refinamiento <i>step-wise</i></li>

</ul></li>
<li>Finales de los 70: De Orientación a Procesos a Orientación a Datos.
<ul>
<li>Abstracción de Datos</li>

</ul></li>
<li>Mediados de los 80: Programación orientada a Objetos
<ul>
<li>Abstracción de Datos + Herencia + Polimorfismo</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline12">
<div class="slide-header"></div>
<h4 id="orgheadline12">Categoría de Lenguajes</h4>
<ul>
<li>Imperativa
<ul>
<li>Variables, sentencias de asignación e iteración</li>
<li>Ejemplos: C, Pascal</li>

</ul></li>
<li>Funcional
<ul>
<li>Principal medio de computación es aplicar funciones a parámetros</li>
<li>Ejemplos: LISP, Scheme</li>

</ul></li>
<li>Lógica
<ul>
<li>Basado en Reglas</li>
<li>Ejemplo: Prolog</li>

</ul></li>
<li>Orientado a Objetos
<ul>
<li>abstracción de datos, herencia, ligadura tardía</li>
<li>Ejemplos: Java, C++</li>

</ul></li>
<li>Marcado
<ul>
<li>No programación per se, pero usados para especificar la
información mostrada en documentos web</li>
<li>Ejemplos: XHTML, XML</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline13">
<div class="slide-header"></div>
<h4 id="orgheadline13">Compromisos en el diseño de Lenguajes</h4>
<ul>
<li>Confiabilidad vs. Costo de ejecución
<ul>
<li>Ejemplo: Java exige que todas las referencias a elementos de los
arreglos sean chequeadas si la indexación es correcta, pero esto
incrementa el costo de ejecución</li>

</ul></li>
<li>Legibilidad vs. Escribilidad
<ul>
<li>Ejemplo: APL provee muchos operadores poderosos (y un gran numero
de nuevos simbolos) permitiendo que complejas operaciones sean
escritas en un programa compacto pero con el costo de pobre legibilidad</li>

</ul></li>
<li>Flexibilidad vs. Confiabilidad
<ul>
<li>Ejemplo: Los punteros de C++ son poderosos y muy flexibles pero de
un uso poco confiable.</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline28">
<div class="slide-header"></div>
<h3 id="orgheadline28">Métodos de Implementación</h3>
<ul>
<li>Compilación
<ul>
<li>Los programas son traducidos al lenguaje máquina</li>

</ul></li>
<li>Interpretación Pura
<ul>
<li>Los programas son interpretados por otro programa llamado intérprete</li>

</ul></li>
<li>Sistemas de implementación híbridos
<ul>
<li>Un compromiso entre compilación y interpretación pura</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline15">
<div class="slide-header"></div>
<h4 id="orgheadline15">Capas de Implementación de Lenguajes</h4>

<figure>
<p><img src="interfacecapas.png" alt="interfacecapas.png">
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline16">
<div class="slide-header"></div>
<h4 id="orgheadline16">Compilación</h4>
<ul>
<li>Traduce programas de alto nivel (lenguaje fuente) en codigo máquina</li>
<li>Traducción lenta, ejecución rápida</li>
<li>El proceso de compilación tiene varias faces:
<ul>
<li>análisis lexico: convierte caracteres del programa fuente en
unidades léxicas</li>
<li>análisis sintáctico: Transforma unidades léxicas en árboles
sintácticos <i>parse trees</i></li>
<li>análisis semántico: Genera código intermedio</li>
<li>generación de código: Codigo máquina es generado</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline17">
<div class="slide-header"></div>
<h4 id="orgheadline17">El proceso de compilación</h4>

<figure>
<p><img src="procesocomp.png" alt="procesocomp.png"> 
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline18">
<div class="slide-header"></div>
<h4 id="orgheadline18">Terminología Adicional de Compilación</h4>
<ul>
<li>Módulo de carga (imagen ejecutable) : El código del usuario y del
sistema juntos</li>
<li><i>linking and loading</i> Enlazado y Carga: El proceso de recolectar los
programas del sistema y enlazarlo al programa del usuario</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline19">
<div class="slide-header"></div>
<h4 id="orgheadline19">Ejecución del Código Máquina</h4>
<ul>
<li>ciclo de traer y ejecutar (sobre una arquitectura Von Neumann)</li>

</ul>

<div class="org-src-container">

<pre  class="src src-pascal"><span style="color: #00ffff;">repeat</span>  por siempre
   traer la instrucci&#243;n apuntada por el contador
   incrementar el contador
   decodificar la instrucci&#243;n
   ejecutar la instrucci&#243;n
<span style="color: #00ffff;">end</span> <span style="color: #00ffff;">repeat</span>
</pre>
</div>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline20">
<div class="slide-header"></div>
<h4 id="orgheadline20"><i>Cuello de botella</i> de Von Neumann</h4>
<ul>
<li>La velocidad de conección entre la memoria de la computadora y su
procesador determina la velocidad de la computadora</li>
<li>Las intrucciones del programa son ejecutadas mucho mas rápido que la
velocidad de conección; por lo tanto ésta se vuelve el <i>cuello de botella</i></li>
<li>Es conocido que <i>cuello de botella</i> de la arquitectura de Von
Neumann es el principal factor en la velocidad de las computadoras</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline21">
<div class="slide-header"></div>
<h4 id="orgheadline21">Interpretación Pura</h4>
<ul>
<li>Sin traducción</li>
<li>Facil implementación de programas. Errores de tiempo de ejecución
pueden ser facilmente reconocidos</li>
<li>Ejecución mas lenta (10 a 100 veces mas lenta que programas compilados)</li>
<li>Frecuentemente requiere mas espacio</li>
<li>Se volvio infrecuente en lenguajes de alto nivel</li>
<li>Han retornado con lenguajes de <i>sripting</i> para la Web (e.g. JavaScript)</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline22">
<div class="slide-header"></div>
<h4 id="orgheadline22">Proceso de Interpretación Pura</h4>

<figure>
<p><img src="procesointerppuro.png" alt="procesointerppuro.png">
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline23">
<div class="slide-header"></div>
<h4 id="orgheadline23">Sistemas de Implementación Híbrida</h4>
<ul>
<li>Un compromiso entre compilador y intérprete puro</li>
<li>El programa en lenguaje de alto nivel es traducido a un lenguaje
intermedio que permite facil interpretación</li>
<li>Mucho mas rápido que interpretación pura</li>
<li>Ejemplos
<ul>
<li>Programas en Perl son parcialmente compilados para detectar
errores antes de la interpretación</li>
<li>Implementaciones iniciales de Java fueron híbridas, la forma
intermedia <i>byte code</i>, proveyó portabilidad a toda máquina que
tenía un interprete de <i>byte code</i> y un sistema de <i>run time</i>
(juntos son llamados la máquina virtual de java)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline24">
<div class="slide-header"></div>
<h4 id="orgheadline24">Proceso de Implementación Híbrida</h4>

<figure>
<p><img src="procesohibrido.png" alt="procesohibrido.png"> 
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline25">
<div class="slide-header"></div>
<h4 id="orgheadline25">Sistemas de Implementación <i>Just in Time</i></h4>
<ul>
<li>Inicialmente Los programas se traducen a un lenguaje intermedio</li>
<li>Luego el lenguaje intermedio se compila a código máquina</li>
<li>La versión en máquina se conserva para llamadas subsecuentes</li>
<li>Sistemas JIT son ampliamente usados para programas Java</li>
<li>Lenguajes .NET son implementados con sistemas JIT</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline26">
<div class="slide-header"></div>
<h4 id="orgheadline26">Preprocesadores</h4>
<ul>
<li>Macros de preprocesamiento (instrucciones) son comunmente usadas
para especificar que código de otros archivos sean incluidos</li>
<li>Un preprocesador procesa un programa inmediatamente antes de que el
programa se compilada para expandir las macros incluídas</li>
<li>Un ejemplo conocido: El preprocesador de C
<ul>
<li>expands #include, #define, y macros similares</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline27">
<div class="slide-header"></div>
<h4 id="orgheadline27">Entornos de Programación</h4>
<ul>
<li>Una colección de herramientas usadas en el desarrollo de software</li>
<li>UNIX
<ul>
<li>un tradicional sistema operativo y colección de herramientas</li>
<li>hoy en dia frecuentemente usado a través de un GUI que corren
sobre UNIX</li>

</ul></li>
<li>Borland JBuilder
<ul>
<li>Un entorno de programación integrado para Java</li>

</ul></li>
<li>Microsoft Visual Studio .NET
<ul>
<li>Un complejo entorno visual de desarrollo</li>
<li>Usado para programar en C#, Visual Basic .NET, jscript, J# o C++</li>

</ul></li>

</ul>


<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline65">
<div class="slide-header"></div>
<h2 id="orgheadline65">Evolución de los Lenguajes de Programación</h2>
<div class="outline-text-2" id="text-orgheadline65">
</div><div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline30">
<div class="slide-header"></div>
<h3 id="orgheadline30">Lenguajes de Programación</h3>

<figure>
<p><img src="evolleng.png" alt="evolleng.png">
</p>
</figure>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline31">
<div class="slide-header"></div>
<h3 id="orgheadline31">Evolución de los primeros lenguajes</h3>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline33">
<div class="slide-header"></div>
<h3 id="orgheadline33">Konrad Zuze's language de la computadora Z4.</h3>
<div class="outline-text-3" id="text-orgheadline33">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgheadline32">
<div class="slide-header"></div>
<h4 id="orgheadline32">Zuse's Plankalkül</h4>
<ul>
<li>Desarrollado en 1945</li>
<li>Nunca implementado</li>
<li>Su descripción fue publicada en 1972.</li>
<li>Tipos de datos: bit, Integer and float tipos compuestos.</li>
<li>arreglos y registros</li>

</ul>

<div class="org-src-container">

<pre  class="src src-lisp">  | A + 1 =&gt; A
V | 4        5
S | 1.n      1.n
</pre>
</div>




<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline38">
<div class="slide-header"></div>
<h3 id="orgheadline38">Codigo Máquina: pseudocodigos ¿?</h3>
<div class="outline-text-3" id="text-orgheadline38">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgheadline34">
<div class="slide-header"></div>
<h4 id="orgheadline34">Escribir en lenguaje máquina</h4>
<ul>
<li>poco legibles y modificables</li>
<li>sin indices ni punto flotante</li>
<li>direccionamiento absoluto</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline35">
<div class="slide-header"></div>
<h4 id="orgheadline35">Shorte Code Mauchly (1949)</h4>
<ul>
<li>computadora BINAC</li>
<li>Expresiones eran codificadas de izquierda a derecha</li>
<li>Ejemplos de operaciones:</li>

</ul>

<div class="org-src-container">

<pre  class="src src-lisp">01 - 06 abs value 1n (n+2)nd power
02 ) 07 +         2n (n+2)nd root
03 = 08 pause     4n if &lt;= n
04 / 09 (         58 print and tab
</pre>
</div>

<p>
La sentencia X0 = SQRT(ABS(Y0)) podria ser codificada como:
</p>

<div class="org-src-container">

<pre  class="src src-lisp">00 X0 03 20 06 Y0
</pre>
</div>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline36">
<div class="slide-header"></div>
<h4 id="orgheadline36">Speedcoding</h4>
<ul>
<li>Desarrollado por John Backus en 1954 para IBM 701</li>
<li>Pseudo operaciones para funciones aritméticas y matemtaticas
<ul>
<li>bifurcación condicional e incondicional</li>
<li>registros autoincrementales para acceso a arreglos</li>
<li>4.2 millisegundos la instruccion de suma y 700 palabras para el programa</li>
<li>2 semanas de programación en pocas horas!!!</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline37">
<div class="slide-header"></div>
<h4 id="orgheadline37">Otros sistemas relacionados</h4>
<ul>
<li>Sistema de "compilación" UNIVAC
<ul>
<li>Desarrollado por el equipo de Brace Hopper</li>
<li>Pseudocodigo expandido en código máquina (macros)</li>

</ul></li>
<li>David J Wheeler (Universidad de Cambridge) (1950)
<ul>
<li>Desarrollo un método de usar bloques de direccionamiento reubicables</li>

</ul></li>
<li>Wilkes (1951-1957) desarrollo lenguaje <i>assembler</i> con estas ideas</li>

</ul>


<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline48">
<div class="slide-header"></div>
<h3 id="orgheadline48">IBM 704 y Fortran</h3>
<div class="outline-text-3" id="text-orgheadline48">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgheadline39">
<div class="slide-header"></div>
<h4 id="orgheadline39">Fortan</h4>
<ul>
<li>Fortran 0: 1954 - no implementado</li>
<li>Fortran 1 1957
<ul>
<li>Diseñado para la nueva IBM 704, que tenía registros y aritmética
de punto flotante</li>
<li>Entorno de Desarrollo
<ul>
<li>Las Computadoras eran pequeñas y confiables</li>
<li>Las aplicaciones eran científicas</li>
<li>Sin metodología ni herramientas de programación</li>
<li>Importancia en <b>eficiencia</b></li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline40">
<div class="slide-header"></div>
<h4 id="orgheadline40">Proceso de Diseño</h4>
<ul>
<li>El impacto del entorno en el diseño de Fortran
<ul>
<li>Sin necesidad de almacenamiento dinámico</li>
<li>Necesidad de un buen manejo de arreglos y ciclos</li>
<li>Sin manejo de cadenas, aritmética decimal o herramientas de
entrada/salida (de uso comercial)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline41">
<div class="slide-header"></div>
<h4 id="orgheadline41">Fortran I</h4>
<ul>
<li>Primera versión implementada de Fortrand
<ul>
<li>Nombres hasta 6 caracteres</li>
<li>Ciclos iterativos con post condición (<b>DO</b>)</li>
<li>I/O formateada</li>
<li>subprogramas definidos por el usuario</li>
<li>Sentencias condicionales de tres modos (<b>IF</b> aritmético)</li>
<li>sentencias sin tipo de datos</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline42">
<div class="slide-header"></div>
<h4 id="orgheadline42">Fortran I</h4>
<ul>
<li>Primera versión implementada
<ul>
<li>Sin compilación separada</li>
<li>Compilador distribuido en Abril de 1957,</li>
<li>Programas de mas de 400 lineas raramente compilaban correctamente,
principalmente debido a la pobre confiabilidad de la IBM 704</li>
<li>La Codificación era verdaderamente rápida</li>
<li>Rapidamente se volvió ampliamente usado</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline43">
<div class="slide-header"></div>
<h4 id="orgheadline43">Fortran II</h4>
<ul>
<li>Distribuido en 1958
<ul>
<li>Compilación independiente</li>
<li>Se corrigieron muchos errores</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline44">
<div class="slide-header"></div>
<h4 id="orgheadline44">Fortran IV</h4>
<ul>
<li>Desarrollado durante 1960-1962
<ul>
<li>Declaración explicita de tipos</li>
<li>Sentencia de selección lógica</li>
<li>Nombres de programas podian se pasados como parámetros</li>
<li>ANSI standard en 1966</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline45">
<div class="slide-header"></div>
<h4 id="orgheadline45">Fortran 77</h4>
<ul>
<li>Se volvió el nuevo estandard en 1978
<ul>
<li>Manejo de cadenas de caracteres</li>
<li>sentencia de control de ciclos lógico</li>
<li>sentencia <b>IF-THEN-ELSE</b></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline46">
<div class="slide-header"></div>
<h4 id="orgheadline46">Fortran 90</h4>
<ul>
<li>Con los mas significativos cámbios desde el Fortran 77
<ul>
<li>Módulos</li>
<li>Arreglos dinámicos</li>
<li>Punteros</li>
<li>Recursión</li>
<li>sentencia <b>CASE</b></li>
<li>chequeo de tipos en los parametros</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline47">
<div class="slide-header"></div>
<h4 id="orgheadline47">Evaluación de Fortran</h4>
<ul>
<li>Compiladores altamente optimizados (todas las versiones anteriores a 90)
<ul>
<li>Los tipos y almacenamiento de todas las variables eran fijas antes del
tiempo de ejecución.</li>

</ul></li>
<li>Dramaticamente cambió para siempre el modo en que las computadoras
fueron usadas</li>
<li>Caracterizados como la <i>lingua franca</i> del mundo de la computación</li>

</ul>


<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline54">
<div class="slide-header"></div>
<h3 id="orgheadline54">Programación Funcional: LISP</h3>
<div class="outline-text-3" id="text-orgheadline54">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgheadline49">
<div class="slide-header"></div>
<h4 id="orgheadline49">LISP</h4>
<ul>
<li><i>LISt Processing Language</i>
<ul>
<li>Diseñado en el MIT por McCarthy</li>

</ul></li>
<li>Investigación en AI necesitaba un lenguaje
<ul>
<li>Procesamiento de datos en Listas (en lugar de arreglos)</li>
<li>Computación simbólica (en lugar de numérica)</li>

</ul></li>
<li>Solo dos tipos de datos: átomos y listas</li>
<li>Basado en el <b>Lambda calculus</b></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline50">
<div class="slide-header"></div>
<h4 id="orgheadline50">Representación de Listas LISP</h4>

<figure>
<p><img src="represlistas.png" alt="represlistas.png">
</p>
</figure>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline51">
<div class="slide-header"></div>
<h4 id="orgheadline51">Evaluación de LISP</h4>
<ul>
<li>Pionero en programación funcional
<ul>
<li>Sin necesidad de variables o asignación</li>
<li>Control via recursión y expresiones condicionales</li>

</ul></li>
<li>Aún un lenguaje dominante para IA</li>
<li>COMMON LISP y Scheme son dialectos contemporaneos de LISP</li>
<li>ML, Miranda, Haskell son lenguajes relacionados</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline52">
<div class="slide-header"></div>
<h4 id="orgheadline52">Scheme</h4>
<ul>
<li>Desarrollado en el MIT a mediados de los 70</li>
<li>Pequeño</li>
<li>Extensivo uso de alcance estático</li>
<li>Funciones como entidades de primera clase</li>
<li>Sintaxis simple, ideal para aplicaciones educativas</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline53">
<div class="slide-header"></div>
<h4 id="orgheadline53">COMMON LISP</h4>
<ul>
<li>Un esfuerzo por combinar características de varios dialectos de LISP
en un solo lenguaje</li>
<li>Grande y Complejo</li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline62">
<div class="slide-header"></div>
<h3 id="orgheadline62">Primera sofisticación: ALGOL 60</h3>
<div class="outline-text-3" id="text-orgheadline62">
</div><div class="slide-footer"></div>
</section>
<section id="slide-orgheadline55">
<div class="slide-header"></div>
<h4 id="orgheadline55">Algol 60</h4>
<ul>
<li>Entorno de Desarrollo
<ul>
<li>FORTRAN había arribado para las IBM 70x</li>
<li>Muchos lenguajes se habían desarrollado para máquinas específicas</li>
<li>Ningún lenguaje era portable; todos eran dependiente de las máquinas</li>
<li>No existía ningún lenguaje universal para comunicar algoritmos</li>

</ul></li>
<li>ALGOL 60 fue el resultado del esfuerzo de designar un lenguaje universal</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline56">
<div class="slide-header"></div>
<h4 id="orgheadline56">Primitivo proceso de diseño</h4>
<ul>
<li>Encuentro de ACM y GAMM para cuatro dias de diseño (27 de Mayo al 1
de Junio de 1958)</li>
<li>Metas del Lenguaje
<ul>
<li>Cercano a la notación matemática</li>
<li>Bueno para describir algoritmos</li>
<li>Traducible a lenguaje máquina</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline57">
<div class="slide-header"></div>
<h4 id="orgheadline57">ALGOL 58</h4>
<ul>
<li>El concepto de tipos fue formalizado</li>
<li>Los nombre podrían tener cualquier longitud</li>
<li>Los arreglos podrían tener cualquier número de subíndices</li>
<li>Los parámetros fueron separados por modo (Entrada y Salida)</li>
<li>Subíndices fueron colocados entre corchetes</li>
<li>Sentencias compuestas (<b>begin &#x2026; end</b>)</li>
<li>Punto y coma como separador de sentencias</li>
<li>Operador de asignación fue <b>:=</b></li>
<li><b>if</b> tenía una cláusula <b>else-if</b></li>
<li>Sin E/S - "podría hacerlo dependiente de la máquina"</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline58">
<div class="slide-header"></div>
<h4 id="orgheadline58">Implementación de ALGOL 58</h4>
<ul>
<li>Sin intención de ser implementado, sin embargo variaciones de él si
lo fueron (MAD, JOVIAL)</li>
<li>Aunque IBM fue inicialmente entusiasta, todo soporte fue quitado a
mediados de 1959</li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline59">
<div class="slide-header"></div>
<h4 id="orgheadline59">ALGOL 60</h4>
<ul>
<li>Se modificó ALGOL 58 en una reunión de 6 dias en Paris</li>
<li>Nuevas Características
<ul>
<li>Estructura de bloques (alcance local)</li>
<li>Dos métodos de pasaje de parámetros</li>
<li>Recursión de subprogramas</li>
<li>arreglos dinámicos (basados en pilas)</li>
<li>Todavía sin E/S ni manejo de cadenas de caracteres</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline60">
<div class="slide-header"></div>
<h4 id="orgheadline60">Evaluación de ALGOL 60</h4>
<ul>
<li>Exitoso
<ul>
<li>Fue el modo estándar de publicar algoritmos por los siguientes 20 años</li>
<li>Todo subsecuente lenguaje imperativo fue basado en él</li>
<li>Primer lenguaje independiente de la máquina</li>
<li>Primer lenguaje cuya sintaxis fue formalmente definida (BNF)</li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
<section id="slide-orgheadline61">
<div class="slide-header"></div>
<h4 id="orgheadline61">Evaluación de ALGOL 60</h4>
<ul>
<li>Fracaso
<ul>
<li>Nunca fue ampliamente usado, especialmente en U.S.</li>
<li>Razones:
<ul>
<li>Falta de E/S y el conjunto de caracteres lo hacía no portable</li>
<li>Demasiado flexible para implementar</li>
<li>Falta de soporte de IBM</li>

</ul></li>

</ul></li>

</ul>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline63">
<div class="slide-header"></div>
<h3 id="orgheadline63">Aplicaciones Comerciales: COBOL</h3>

<div class="slide-footer"></div>
</section>
</section>
<section>
<section id="slide-orgheadline64">
<div class="slide-header"></div>
<h3 id="orgheadline64">Comienzo de tiempo compartido: BASIC</h3>
<div class="slide-footer"></div>
</section>
</section>
</div>
</div>
<script src="../reveal.js-master/lib/js/head.min.js"></script>
<script src="../reveal.js-master/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: true,
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'cube', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
]
,});
</script>
</body>
</html>
